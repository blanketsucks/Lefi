{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lefi A discord API wrapper focused on clean code, and usability Features Asynchronous - Almost everything is async except for few unavoidable ones. Object oriented - Allows for easy usage Get started here","title":"Home"},{"location":"#lefi","text":"A discord API wrapper focused on clean code, and usability","title":"Lefi"},{"location":"#features","text":"Asynchronous - Almost everything is async except for few unavoidable ones. Object oriented - Allows for easy usage Get started here","title":"Features"},{"location":"getting-started/","text":"Getting started Table of contents Installation Basic usage Installing To install the wrapper you can use pip , poetry or any other manager you use. Note: It is recommended to use poetry or any other venv when downloading Poetry poetry add git+https://github.com/an-dyy/Lefi.git --no-dev Note: If you plan on contributing, omit the --no-dev flag. Pip pip install git+https://github.com/an-dyy/Lefi.git Examples import os import asyncio import lefi async def main () -> None : token = os . getenv ( \"discord_token\" ) # NOTE: I'm on linux so I can just export, windows might need a `.env` client = lefi . Client ( token ) # type: ignore @client . once ( \"ready\" ) async def on_ready ( client_user : lefi . User ) -> None : print ( f \"LOGGED IN AS { client_user . id } \" ) @client . on ( \"message_create\" ) async def message_create ( message : lefi . Message ) -> None : print ( message ) await client . start () asyncio . run ( main ())","title":"Getting-Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#table-of-contents","text":"Installation Basic usage","title":"Table of contents"},{"location":"getting-started/#installing","text":"To install the wrapper you can use pip , poetry or any other manager you use. Note: It is recommended to use poetry or any other venv when downloading Poetry poetry add git+https://github.com/an-dyy/Lefi.git --no-dev Note: If you plan on contributing, omit the --no-dev flag. Pip pip install git+https://github.com/an-dyy/Lefi.git","title":"Installing"},{"location":"getting-started/#examples","text":"import os import asyncio import lefi async def main () -> None : token = os . getenv ( \"discord_token\" ) # NOTE: I'm on linux so I can just export, windows might need a `.env` client = lefi . Client ( token ) # type: ignore @client . once ( \"ready\" ) async def on_ready ( client_user : lefi . User ) -> None : print ( f \"LOGGED IN AS { client_user . id } \" ) @client . on ( \"message_create\" ) async def message_create ( message : lefi . Message ) -> None : print ( message ) await client . start () asyncio . run ( main ())","title":"Examples"},{"location":"API-Reference/cache/","text":"A class which acts as a cache for objects. Attributes: Name Type Description maxlen Optional[int] The max amount the cache can hold. __init__ ( self , maxlen = None , * args , ** kwargs ) special Parameters: Name Type Description Default maxlen Optional[int] The max amount the cache can hold. None Source code in lefi/state.py def __init__ ( self , maxlen : Optional [ int ] = None , * args , ** kwargs ): \"\"\" Parameters: maxlen (Optional[int]): The max amount the cache can hold. \"\"\" super () . __init__ ( * args , ** kwargs ) self . maxlen : Optional [ int ] = maxlen self . _max : int = 0","title":"Cache"},{"location":"API-Reference/cache/#lefi.state.Cache.__init__","text":"Parameters: Name Type Description Default maxlen Optional[int] The max amount the cache can hold. None Source code in lefi/state.py def __init__ ( self , maxlen : Optional [ int ] = None , * args , ** kwargs ): \"\"\" Parameters: maxlen (Optional[int]): The max amount the cache can hold. \"\"\" super () . __init__ ( * args , ** kwargs ) self . maxlen : Optional [ int ] = maxlen self . _max : int = 0","title":"__init__()"},{"location":"API-Reference/channel/","text":"A class representing a discord channel. guild : Guild property readonly A lefi.Guild instance which the channel belongs to. id : int property readonly The channels id. name : str property readonly The channels name. type : ChannelType property readonly The type of the channel. nsfw : bool property readonly Whether or not the channel is marked as NSFW. position : int property readonly The position of the channel. overwrites : List [ Overwrite ] property readonly A list of lefi.Overwrite s for the channel.","title":"Channel"},{"location":"API-Reference/channel/#lefi.objects.channel.Channel.guild","text":"A lefi.Guild instance which the channel belongs to.","title":"guild"},{"location":"API-Reference/channel/#lefi.objects.channel.Channel.id","text":"The channels id.","title":"id"},{"location":"API-Reference/channel/#lefi.objects.channel.Channel.name","text":"The channels name.","title":"name"},{"location":"API-Reference/channel/#lefi.objects.channel.Channel.type","text":"The type of the channel.","title":"type"},{"location":"API-Reference/channel/#lefi.objects.channel.Channel.nsfw","text":"Whether or not the channel is marked as NSFW.","title":"nsfw"},{"location":"API-Reference/channel/#lefi.objects.channel.Channel.position","text":"The position of the channel.","title":"position"},{"location":"API-Reference/channel/#lefi.objects.channel.Channel.overwrites","text":"A list of lefi.Overwrite s for the channel.","title":"overwrites"},{"location":"API-Reference/client/","text":"A class used to communicate with the discord API and its gateway. Attributes: Name Type Description pub_key Optional[str] The client's public key. Used when handling interactions over HTTP. loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop which is being used. http lefi.HTTPClient The HTTPClient to use for handling requests to the API. ws lefi.WebSocketClient The WebSocketClient which handles the gateway. __init__ ( self , token , * , intents = None , loop = None ) special Parameters: Name Type Description Default token str The clients token, used for authorization (logging in, etc...) This is required. required intents Optional[lefi.Intents] The intents to be used for the client. None loop Optional[asyncio.AbstractEventLoop] The loop to use. None Source code in lefi/client.py def __init__ ( self , token : str , * , intents : Intents = None , loop : Optional [ asyncio . AbstractEventLoop ] = None , ): \"\"\" Parameters: token (str): The clients token, used for authorization (logging in, etc...) This is required. intents (Optional[lefi.Intents]): The intents to be used for the client. loop (Optional[asyncio.AbstractEventLoop]): The loop to use. \"\"\" self . loop : asyncio . AbstractEventLoop = loop or asyncio . get_running_loop () self . http : HTTPClient = HTTPClient ( token , self . loop ) self . _state : State = State ( self , self . loop ) self . ws : WebSocketClient = WebSocketClient ( self , intents ) self . events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . once_events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . futures : Dict [ str , List [ Tuple [ asyncio . Future , Callable [ ... , bool ]]]] = {} add_listener ( self , func , event_name ) Registers listener, basically connecting an event to a callback. Parameters: Name Type Description Default func Callable[..., Coroutine] The callback to register for an event. required event_name Optional[str] The event to register, if None it will pass the decorated functions name. required Source code in lefi/client.py def add_listener ( self , func : Callable [ ... , Coroutine ], event_name : Optional [ str ], ) -> None : \"\"\" Registers listener, basically connecting an event to a callback. Parameters: func (Callable[..., Coroutine]): The callback to register for an event. event_name (Optional[str]): The event to register, if None it will pass the decorated functions name. \"\"\" name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . events . setdefault ( name , []) callbacks . append ( func ) on ( self , event_name = None ) A decorator that registers the decorated function to an event. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Examples: @client . on ( \"message_create\" ) async def on_message ( message : lefi . Message ) -> None : await message . channel . send ( \"Got your message!\" ) @client . on ( \"message_create\" ) async def on_message ( message : lefi . Message ) -> None : await message . channel . send ( \"Got your message!\" ) @client . on ( \"message_create\" ) async def on_message2 ( message : lefi . Message ) -> None : print ( message . content ) Source code in lefi/client.py def on ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Parameters: event_name (Optional[str]): The event to register. Note: The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: The decorated function after registering it as a listener. Example: ```py @client.on(\"message_create\") async def on_message(message: lefi.Message) -> None: await message.channel.send(\"Got your message!\") ``` ```py @client.on(\"message_create\") async def on_message(message: lefi.Message) -> None: await message.channel.send(\"Got your message!\") @client.on(\"message_create\") async def on_message2(message: lefi.Message) -> None: print(message.content) ``` \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: self . add_listener ( func , event_name ) return func return inner once ( self , event_name = None ) A decorator that registers the decorated function to an event. Similar to lefi.Client.on but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with lefi.Client.once take precedence over the regular events. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Examples: @client . once ( \"ready\" ) async def on_ready ( client_user : lefi . User ) -> None : print ( f \"logged in as { client_user . username } \" ) Source code in lefi/client.py def once ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Similar to [lefi.Client.on][] but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: event_name (Optional[str]): The event to register. Note: Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with [lefi.Client.once][] take precedence over the regular events. Returns: The decorated function after registering it as a listener. Example: ```py @client.once(\"ready\") async def on_ready(client_user: lefi.User) -> None: print(f\"logged in as {client_user.username}\") ``` \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . once_events . setdefault ( name , []) callbacks . append ( func ) return func return inner connect ( self ) async A method which starts the connection to the gateway. Source code in lefi/client.py async def connect ( self ) -> None : \"\"\" A method which starts the connection to the gateway. \"\"\" await self . ws . start () login ( self ) async A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. Source code in lefi/client.py async def login ( self ) -> None : \"\"\" A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. \"\"\" await self . http . login () start ( self ) async A method which calls lefi.Client.login and lefi.Client.connect in that order. Source code in lefi/client.py async def start ( self ) -> None : \"\"\" A method which calls [lefi.Client.login][] and [lefi.Client.connect][] in that order. \"\"\" await asyncio . gather ( self . login (), self . connect ()) wait_for ( self , event , * , check = None , timeout = None ) async Waits for an event to be dispatched that passes the check. Parameters: Name Type Description Default event str The event to wait for. required check Callable[..., bool] A function that takes the same args as the event, and returns a bool. None timeout float The time to wait before stopping. None Returns: Type Description Any The return from a callback that matches with the event you are waiting for. Note The check has to take in the same args as the event. If no check is passed, everything will complete the check. Examples: @client . on ( \"message_create\" ) async def on_message ( message : lefi . Message ) -> None : if message . content == \"wait for next!\" : next_message = await client . wait_for ( \"message_create\" , check = lambda msg : msg . author . id == 270700034985558017 ) await message . channel . send ( f \"got your message! ` { next_message . content } `\" ) Source code in lefi/client.py async def wait_for ( self , event : str , * , check : Callable [ ... , bool ] = None , timeout : float = None ) -> Any : \"\"\" Waits for an event to be dispatched that passes the check. Parameters: event (str): The event to wait for. check (Callable[..., bool]): A function that takes the same args as the event, and returns a bool. timeout (float): The time to wait before stopping. Returns: The return from a callback that matches with the event you are waiting for. Note: The check has to take in the same args as the event. If no check is passed, everything will complete the check. Example: ```py @client.on(\"message_create\") async def on_message(message: lefi.Message) -> None: if message.content == \"wait for next!\": next_message = await client.wait_for( \"message_create\", check=lambda msg: msg.author.id == 270700034985558017 ) await message.channel.send(f\"got your message! `{next_message.content}`\") ``` \"\"\" future = self . loop . create_future () futures = self . futures . setdefault ( event , []) if check is None : check = lambda * _ : True futures . append (( future , check )) return await asyncio . wait_for ( future , timeout = timeout ) get_message ( self , id ) Grabs a lefi.Message instance if cached. Parameters: Name Type Description Default id int The message's ID. required Returns: Type Description Optional[Message] The lefi.Message instance related to the ID. Else None if not found. Source code in lefi/client.py def get_message ( self , id : int ) -> Optional [ Message ]: \"\"\" Grabs a [lefi.Message][] instance if cached. Parameters: id (int): The message's ID. Returns: The [lefi.Message][] instance related to the ID. Else None if not found. \"\"\" return self . _state . get_message ( id ) get_guild ( self , id ) Grabs a lefi.Guild instance if cached. Parameters: Name Type Description Default id int The guild's ID. required Returns: Type Description Optional[Guild] The lefi.Guild instance related to the ID. Else None if not found Source code in lefi/client.py def get_guild ( self , id : int ) -> Optional [ Guild ]: \"\"\" Grabs a [lefi.Guild][] instance if cached. Parameters: id (int): The guild's ID. Returns: The [lefi.Guild][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_guild ( id ) get_channel ( self , id ) Grabs a lefi.Channel instance if cached. Parameters: Name Type Description Default id int The channel's ID. required Returns: Type Description Optional[Union[TextChannel, VoiceChannel, DMChannel, CategoryChannel, Channel]] The lefi.Channel instance related to the ID. Else None if not found Source code in lefi/client.py def get_channel ( self , id : int ) -> Optional [ Union [ TextChannel , VoiceChannel , DMChannel , CategoryChannel , Channel ]]: \"\"\" Grabs a [lefi.Channel][] instance if cached. Parameters: id (int): The channel's ID. Returns: The [lefi.Channel][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_channel ( id ) get_user ( self , id ) Grabs a lefi.User instance if cached. Parameters: Name Type Description Default id int The user's ID. required Returns: Type Description Optional[User] The lefi.User instance related to the ID. Else None if not found Source code in lefi/client.py def get_user ( self , id : int ) -> Optional [ User ]: \"\"\" Grabs a [lefi.User][] instance if cached. Parameters: id (int): The user's ID. Returns: The [lefi.User][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_user ( id )","title":"Client"},{"location":"API-Reference/client/#lefi.client.Client.__init__","text":"Parameters: Name Type Description Default token str The clients token, used for authorization (logging in, etc...) This is required. required intents Optional[lefi.Intents] The intents to be used for the client. None loop Optional[asyncio.AbstractEventLoop] The loop to use. None Source code in lefi/client.py def __init__ ( self , token : str , * , intents : Intents = None , loop : Optional [ asyncio . AbstractEventLoop ] = None , ): \"\"\" Parameters: token (str): The clients token, used for authorization (logging in, etc...) This is required. intents (Optional[lefi.Intents]): The intents to be used for the client. loop (Optional[asyncio.AbstractEventLoop]): The loop to use. \"\"\" self . loop : asyncio . AbstractEventLoop = loop or asyncio . get_running_loop () self . http : HTTPClient = HTTPClient ( token , self . loop ) self . _state : State = State ( self , self . loop ) self . ws : WebSocketClient = WebSocketClient ( self , intents ) self . events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . once_events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . futures : Dict [ str , List [ Tuple [ asyncio . Future , Callable [ ... , bool ]]]] = {}","title":"__init__()"},{"location":"API-Reference/client/#lefi.client.Client.add_listener","text":"Registers listener, basically connecting an event to a callback. Parameters: Name Type Description Default func Callable[..., Coroutine] The callback to register for an event. required event_name Optional[str] The event to register, if None it will pass the decorated functions name. required Source code in lefi/client.py def add_listener ( self , func : Callable [ ... , Coroutine ], event_name : Optional [ str ], ) -> None : \"\"\" Registers listener, basically connecting an event to a callback. Parameters: func (Callable[..., Coroutine]): The callback to register for an event. event_name (Optional[str]): The event to register, if None it will pass the decorated functions name. \"\"\" name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . events . setdefault ( name , []) callbacks . append ( func )","title":"add_listener()"},{"location":"API-Reference/client/#lefi.client.Client.on","text":"A decorator that registers the decorated function to an event. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Examples: @client . on ( \"message_create\" ) async def on_message ( message : lefi . Message ) -> None : await message . channel . send ( \"Got your message!\" ) @client . on ( \"message_create\" ) async def on_message ( message : lefi . Message ) -> None : await message . channel . send ( \"Got your message!\" ) @client . on ( \"message_create\" ) async def on_message2 ( message : lefi . Message ) -> None : print ( message . content ) Source code in lefi/client.py def on ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Parameters: event_name (Optional[str]): The event to register. Note: The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: The decorated function after registering it as a listener. Example: ```py @client.on(\"message_create\") async def on_message(message: lefi.Message) -> None: await message.channel.send(\"Got your message!\") ``` ```py @client.on(\"message_create\") async def on_message(message: lefi.Message) -> None: await message.channel.send(\"Got your message!\") @client.on(\"message_create\") async def on_message2(message: lefi.Message) -> None: print(message.content) ``` \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: self . add_listener ( func , event_name ) return func return inner","title":"on()"},{"location":"API-Reference/client/#lefi.client.Client.once","text":"A decorator that registers the decorated function to an event. Similar to lefi.Client.on but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with lefi.Client.once take precedence over the regular events. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Examples: @client . once ( \"ready\" ) async def on_ready ( client_user : lefi . User ) -> None : print ( f \"logged in as { client_user . username } \" ) Source code in lefi/client.py def once ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Similar to [lefi.Client.on][] but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: event_name (Optional[str]): The event to register. Note: Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with [lefi.Client.once][] take precedence over the regular events. Returns: The decorated function after registering it as a listener. Example: ```py @client.once(\"ready\") async def on_ready(client_user: lefi.User) -> None: print(f\"logged in as {client_user.username}\") ``` \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . once_events . setdefault ( name , []) callbacks . append ( func ) return func return inner","title":"once()"},{"location":"API-Reference/client/#lefi.client.Client.connect","text":"A method which starts the connection to the gateway. Source code in lefi/client.py async def connect ( self ) -> None : \"\"\" A method which starts the connection to the gateway. \"\"\" await self . ws . start ()","title":"connect()"},{"location":"API-Reference/client/#lefi.client.Client.login","text":"A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. Source code in lefi/client.py async def login ( self ) -> None : \"\"\" A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. \"\"\" await self . http . login ()","title":"login()"},{"location":"API-Reference/client/#lefi.client.Client.start","text":"A method which calls lefi.Client.login and lefi.Client.connect in that order. Source code in lefi/client.py async def start ( self ) -> None : \"\"\" A method which calls [lefi.Client.login][] and [lefi.Client.connect][] in that order. \"\"\" await asyncio . gather ( self . login (), self . connect ())","title":"start()"},{"location":"API-Reference/client/#lefi.client.Client.wait_for","text":"Waits for an event to be dispatched that passes the check. Parameters: Name Type Description Default event str The event to wait for. required check Callable[..., bool] A function that takes the same args as the event, and returns a bool. None timeout float The time to wait before stopping. None Returns: Type Description Any The return from a callback that matches with the event you are waiting for. Note The check has to take in the same args as the event. If no check is passed, everything will complete the check. Examples: @client . on ( \"message_create\" ) async def on_message ( message : lefi . Message ) -> None : if message . content == \"wait for next!\" : next_message = await client . wait_for ( \"message_create\" , check = lambda msg : msg . author . id == 270700034985558017 ) await message . channel . send ( f \"got your message! ` { next_message . content } `\" ) Source code in lefi/client.py async def wait_for ( self , event : str , * , check : Callable [ ... , bool ] = None , timeout : float = None ) -> Any : \"\"\" Waits for an event to be dispatched that passes the check. Parameters: event (str): The event to wait for. check (Callable[..., bool]): A function that takes the same args as the event, and returns a bool. timeout (float): The time to wait before stopping. Returns: The return from a callback that matches with the event you are waiting for. Note: The check has to take in the same args as the event. If no check is passed, everything will complete the check. Example: ```py @client.on(\"message_create\") async def on_message(message: lefi.Message) -> None: if message.content == \"wait for next!\": next_message = await client.wait_for( \"message_create\", check=lambda msg: msg.author.id == 270700034985558017 ) await message.channel.send(f\"got your message! `{next_message.content}`\") ``` \"\"\" future = self . loop . create_future () futures = self . futures . setdefault ( event , []) if check is None : check = lambda * _ : True futures . append (( future , check )) return await asyncio . wait_for ( future , timeout = timeout )","title":"wait_for()"},{"location":"API-Reference/client/#lefi.client.Client.get_message","text":"Grabs a lefi.Message instance if cached. Parameters: Name Type Description Default id int The message's ID. required Returns: Type Description Optional[Message] The lefi.Message instance related to the ID. Else None if not found. Source code in lefi/client.py def get_message ( self , id : int ) -> Optional [ Message ]: \"\"\" Grabs a [lefi.Message][] instance if cached. Parameters: id (int): The message's ID. Returns: The [lefi.Message][] instance related to the ID. Else None if not found. \"\"\" return self . _state . get_message ( id )","title":"get_message()"},{"location":"API-Reference/client/#lefi.client.Client.get_guild","text":"Grabs a lefi.Guild instance if cached. Parameters: Name Type Description Default id int The guild's ID. required Returns: Type Description Optional[Guild] The lefi.Guild instance related to the ID. Else None if not found Source code in lefi/client.py def get_guild ( self , id : int ) -> Optional [ Guild ]: \"\"\" Grabs a [lefi.Guild][] instance if cached. Parameters: id (int): The guild's ID. Returns: The [lefi.Guild][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_guild ( id )","title":"get_guild()"},{"location":"API-Reference/client/#lefi.client.Client.get_channel","text":"Grabs a lefi.Channel instance if cached. Parameters: Name Type Description Default id int The channel's ID. required Returns: Type Description Optional[Union[TextChannel, VoiceChannel, DMChannel, CategoryChannel, Channel]] The lefi.Channel instance related to the ID. Else None if not found Source code in lefi/client.py def get_channel ( self , id : int ) -> Optional [ Union [ TextChannel , VoiceChannel , DMChannel , CategoryChannel , Channel ]]: \"\"\" Grabs a [lefi.Channel][] instance if cached. Parameters: id (int): The channel's ID. Returns: The [lefi.Channel][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_channel ( id )","title":"get_channel()"},{"location":"API-Reference/client/#lefi.client.Client.get_user","text":"Grabs a lefi.User instance if cached. Parameters: Name Type Description Default id int The user's ID. required Returns: Type Description Optional[User] The lefi.User instance related to the ID. Else None if not found Source code in lefi/client.py def get_user ( self , id : int ) -> Optional [ User ]: \"\"\" Grabs a [lefi.User][] instance if cached. Parameters: id (int): The user's ID. Returns: The [lefi.User][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_user ( id )","title":"get_user()"},{"location":"API-Reference/dmchannel/","text":"A class that represents a Users DMChannel. id : int property readonly The ID of the DMChannel. type : int property readonly The type of the channel. receipients : List [ User ] property readonly A list of lefi.User instances which are the recipients. send ( self , content = None , * , embeds = None ) async Sends a message to the channel. Parameters: Name Type Description Default content Optional[str] The content of the message. None embeds Optional[List[lefi.Embed]] The list of embeds to send with the message. None Returns: Type Description Message The sent lefi.Message instance. Source code in lefi/objects/channel.py async def send ( self , content : Optional [ str ] = None , * , embeds : Optional [ List [ Embed ]] = None ) -> Message : \"\"\" Sends a message to the channel. Parameters: content (Optional[str]): The content of the message. embeds (Optional[List[lefi.Embed]]): The list of embeds to send with the message. Returns: The sent [lefi.Message][] instance. \"\"\" embeds = [] if embeds is None else embeds data = await self . _state . client . http . send_message ( channel_id = self . id , content = content , embeds = [ embed . to_dict () for embed in embeds ], ) return self . _state . create_message ( data , self )","title":"DMChannel"},{"location":"API-Reference/dmchannel/#lefi.objects.channel.DMChannel.id","text":"The ID of the DMChannel.","title":"id"},{"location":"API-Reference/dmchannel/#lefi.objects.channel.DMChannel.type","text":"The type of the channel.","title":"type"},{"location":"API-Reference/dmchannel/#lefi.objects.channel.DMChannel.receipients","text":"A list of lefi.User instances which are the recipients.","title":"receipients"},{"location":"API-Reference/dmchannel/#lefi.objects.channel.DMChannel.send","text":"Sends a message to the channel. Parameters: Name Type Description Default content Optional[str] The content of the message. None embeds Optional[List[lefi.Embed]] The list of embeds to send with the message. None Returns: Type Description Message The sent lefi.Message instance. Source code in lefi/objects/channel.py async def send ( self , content : Optional [ str ] = None , * , embeds : Optional [ List [ Embed ]] = None ) -> Message : \"\"\" Sends a message to the channel. Parameters: content (Optional[str]): The content of the message. embeds (Optional[List[lefi.Embed]]): The list of embeds to send with the message. Returns: The sent [lefi.Message][] instance. \"\"\" embeds = [] if embeds is None else embeds data = await self . _state . client . http . send_message ( channel_id = self . id , content = content , embeds = [ embed . to_dict () for embed in embeds ], ) return self . _state . create_message ( data , self )","title":"send()"},{"location":"API-Reference/embed/","text":"Embed Represents an Embed. Attributes: Name Type Description title Optional[str] The title of the embed. description Optional[str] The description of the embed. color Optional[int] The color of the embed. url Optional[str] The url of the embed. timestamp Optional[datetime.datetime] The timestamp of the embed. footer Optional[lefi.EmbedFooter] The footer of the embed. image Optional[lefi.EmbedImage] The image of the embed. video Optional[lefi.EmbedVideo] The video of the embed. provider Optional[lefi.EmbedProvider] The provider of the embed. author Optional[lefi.EmbedAuthor] The author of the embed. fields Optional[List[lefi.EmbedField]] The list of fields for the embed. Note You shouldn't be creating all the classes to pass in. Rather use the set_ methods of lefi.Embed __init__ ( self , * , title = None , description = None , color = None , url = None , timestamp = None , footer = None , image = None , video = None , provider = None , author = None , fields = None ) special Parameters: Name Type Description Default title Optional[str] The title of the embed. None description Optional[str] The description of the embed. None color Optional[int] The color of the embed. None url Optional[str] The url of the embed. None timestamp Optional[datetime.datetime] The timestamp of the embed. None footer Optional[lefi.EmbedFooter] The footer of the embed. None image Optional[lefi.EmbedImage] The image of the embed. None video Optional[lefi.EmbedVideo] The video of the embed. None provider Optional[lefi.EmbedProvider] The provider of the embed. None author Optional[lefi.EmbedAuthor] The author of the embed. None fields Optional[List[lefi.EmbedField]] The list of fields for the embed. None Source code in lefi/objects/embed.py def __init__ ( self , * , title : Optional [ str ] = None , description : Optional [ str ] = None , color : Optional [ int ] = None , url : Optional [ str ] = None , timestamp : Optional [ datetime . datetime ] = None , footer : Optional [ EmbedFooter ] = None , image : Optional [ EmbedImage ] = None , video : Optional [ EmbedVideo ] = None , provider : Optional [ EmbedProvider ] = None , author : Optional [ EmbedAuthor ] = None , fields : Optional [ List [ EmbedField ]] = None ) -> None : \"\"\" Parameters: title (Optional[str]): The title of the embed. description (Optional[str]): The description of the embed. color (Optional[int]): The color of the embed. url (Optional[str]): The url of the embed. timestamp (Optional[datetime.datetime]): The timestamp of the embed. footer (Optional[lefi.EmbedFooter]): The footer of the embed. image (Optional[lefi.EmbedImage]): The image of the embed. video (Optional[lefi.EmbedVideo]): The video of the embed. provider (Optional[lefi.EmbedProvider]): The provider of the embed. author (Optional[lefi.EmbedAuthor]): The author of the embed. fields (Optional[List[lefi.EmbedField]]): The list of fields for the embed. \"\"\" self . title = title self . description = description self . color = color self . url = url self . timestamp = timestamp . isoformat () if timestamp is not None else timestamp self . footer = footer self . image = image self . video = video self . provider = provider self . author = author self . fields = [] if fields is None else fields set_footer ( self , * , text , icon_url = None ) Sets the footer of the embed. Parameters: Name Type Description Default text str The text of the footer. required icon_url str The icon url of the footer None Source code in lefi/objects/embed.py def set_footer ( self , * , text : str , icon_url : Optional [ str ] = None ) -> Embed : \"\"\" Sets the footer of the embed. Parameters: text (str): The text of the footer. icon_url (str): The icon url of the footer \"\"\" self . footer = EmbedFooter ( text = text , icon_url = icon_url ) return self set_image ( self , * , url , height = None , width = None ) Sets the image of the embed. Parameters: Name Type Description Default url str The images url. required height Optional[int] The height of the image. None width Optional[int] The width of the image. None Source code in lefi/objects/embed.py def set_image ( self , * , url : str , height : Optional [ int ] = None , width : Optional [ int ] = None ) -> Embed : \"\"\" Sets the image of the embed. Parameters: url (str): The images url. height (Optional[int]): The height of the image. width (Optional[int]): The width of the image. \"\"\" self . image = EmbedImage ( url = url , height = height , width = width ) return self set_video ( self , * , url , height = None , width = None ) Sets the video of the embed. Parameters: Name Type Description Default url str The video url. required height Optional[int] The height of the video. None width Optional[int] The width of the video. None Source code in lefi/objects/embed.py def set_video ( self , * , url : str , height : Optional [ int ] = None , width : Optional [ int ] = None ) -> Embed : \"\"\" Sets the video of the embed. Parameters: url (str): The video url. height (Optional[int]): The height of the video. width (Optional[int]): The width of the video. \"\"\" self . video = EmbedVideo ( url = url , height = height , width = width ) return self set_provider ( self , * , name = None , url = None ) Sets the provider of the embed. Parameters: Name Type Description Default name Optional[str] The name of the provider. None url Optional[str] The url of the provider. None Source code in lefi/objects/embed.py def set_provider ( self , * , name : Optional [ str ] = None , url : Optional [ str ] = None ) -> Embed : \"\"\" Sets the provider of the embed. Parameters: name (Optional[str]): The name of the provider. url (Optional[str]): The url of the provider. \"\"\" self . provider = EmbedProvider ( name = name , url = url ) return self set_author ( self , * , name , url = None , icon_url = None ) Sets the author of the embed. Parameters: Name Type Description Default name str The name of the author. required url Optional[str] The url of the author. None icon_url Optional[str] The icon url of the author. None Source code in lefi/objects/embed.py def set_author ( self , * , name : str , url : Optional [ str ] = None , icon_url : Optional [ str ] = None ) -> Embed : \"\"\" Sets the author of the embed. Parameters: name (str): The name of the author. url (Optional[str]): The url of the author. icon_url (Optional[str]): The icon url of the author. \"\"\" self . author = EmbedAuthor ( name = name , url = url , icon_url = icon_url ) return self add_field ( self , * , name , value , inline = True ) Adds a field to the embed. Parameters: Name Type Description Default name str The name of the field. required value str The vaue of the field. required inline bool Whether the field is inline or not. True Source code in lefi/objects/embed.py def add_field ( self , * , name : str , value : str , inline : bool = True ) -> Embed : \"\"\" Adds a field to the embed. Parameters: name (str): The name of the field. value (str): The vaue of the field. inline (bool): Whether the field is inline or not. \"\"\" self . fields . append ( EmbedField ( name = name , value = value , inline = inline )) return self to_dict ( self ) Turns the embed into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the embed. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the embed into a raw dict. Returns: The dict representing the embed. \"\"\" payload : dict = {} update_payload ( payload , title = self . title , description = self . description , color = self . color , url = self . url , timestamp = self . timestamp , footer = self . _to_dict ( self . footer ), image = self . _to_dict ( self . image ), video = self . _to_dict ( self . video ), provider = self . _to_dict ( self . provider ), author = self . _to_dict ( self . author ), fields = [ field . to_dict () for field in self . fields ], ) return payload EmbedAuthor Represents an Embed's author. Attributes: Name Type Description name str The name of the author. url str The url of the author. icon_url str The icon url of the author. __init__ ( self , * , name , url = None , icon_url = None ) special Parameters: Name Type Description Default name str The name of the author. required url Optional[str] The url of the author. None icon_url Optional[str] The icon url of the author. None Source code in lefi/objects/embed.py def __init__ ( self , * , name : str , url : Optional [ str ] = None , icon_url : Optional [ str ] = None ) -> None : \"\"\" Parameters: name (str): The name of the author. url (Optional[str]): The url of the author. icon_url (Optional[str]): The icon url of the author. \"\"\" self . name = name self . url = url self . icon_url = icon_url to_dict ( self ) Turns the author to a raw dict. Returns: Type Description Dict[str, Any] The dict representing the author. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the author to a raw dict. Returns: The dict representing the author. \"\"\" return update_payload ({}, name = self . name , url = self . url , icon_url = self . icon_url ) EmbedField Represents an Embed's field. Attributes: Name Type Description name str The name of the field. value str The value of the field. inline bool Whether the field is inline or not. __init__ ( self , * , name , value , inline = True ) special Parameters: Name Type Description Default name str The name of the field. required value str The value of the field. required inline bool Whether the field is inline or not. True Source code in lefi/objects/embed.py def __init__ ( self , * , name : str , value : str , inline : bool = True ) -> None : \"\"\" Parameters: name (str): The name of the field. value (str): The value of the field. inline (bool): Whether the field is inline or not. \"\"\" self . name = name self . value = value self . inline = inline to_dict ( self ) Turns the field into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the field. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the field into a raw dict. Returns: The dict representing the field. \"\"\" return update_payload ({}, name = self . name , value = self . value , inline = self . inline ) EmbedFooter Represents an Embed's footer. Attributes: Name Type Description text str The content of the footer. icon_url str The icon url of the footer. __init__ ( self , * , text , icon_url = None ) special Parameters: Name Type Description Default text str The text for the footer. required icon_url Optional[str] The icon url for the footer. None Source code in lefi/objects/embed.py def __init__ ( self , * , text : str , icon_url : Optional [ str ] = None ) -> None : \"\"\" Parameters: text (str): The text for the footer. icon_url (Optional[str]): The icon url for the footer. \"\"\" self . text = text self . icon_url = icon_url to_dict ( self ) Turns the footer into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the footer. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the footer into a raw dict. Returns: The dict representing the footer. \"\"\" payload = { \"text\" : self . text } update_payload ( payload , icon_url = self . icon_url ) return payload EmbedImage Represents an Embed's image. Attributes: Name Type Description url str The image's url. height Optional[int] The height of the image. width Optional[int] The width of the image. to_dict ( self ) Turns the image into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the image. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the image into a raw dict. Returns: The dict representing the image. \"\"\" payload = { \"url\" : self . url } update_payload ( payload , height = self . height , width = self . width ) return payload EmbedProvider Representing an Embed's provider. Attributes: Name Type Description name str The name of the provider. url str The url of the provider. __init__ ( self , * , name = None , url = None ) special Parameters: Name Type Description Default name str The name of the provider. None url str The url of the provider. None Source code in lefi/objects/embed.py def __init__ ( self , * , name : Optional [ str ] = None , url : Optional [ str ] = None ) -> None : \"\"\" Parameters: name (str): The name of the provider. url (str): The url of the provider. \"\"\" self . name = name self . url = url to_dict ( self ) Turns the provider into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the provider. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the provider into a raw dict. Returns: The dict representing the provider. \"\"\" return update_payload ({}, name = self . name , url = self . url ) EmbedVideo ( EmbedImage ) Represents a Embed's video. Attributes: Name Type Description url str The videos url. height Optional[int] The height of the video. width Optional[int] The width of the video. __init__ ( self , * , url , height = None , width = None ) special Parameters: Name Type Description Default url str The url of the video. required height Optional[int] The height of the video. None width Optional[int] The width of the video. None Source code in lefi/objects/embed.py def __init__ ( self , * , url : str , height : Optional [ int ] = None , width : Optional [ int ] = None ) -> None : \"\"\" Parameters: url (str): The url of the video. height (Optional[int]): The height of the video. width (Optional[int]): The width of the video. \"\"\" super () . __init__ ( url = url , height = height , width = width ) to_dict ( self ) Turns the image into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the video. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the image into a raw dict. Returns: The dict representing the video. \"\"\" return update_payload ({}, ** super () . to_dict ())","title":"Embed"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed","text":"Represents an Embed. Attributes: Name Type Description title Optional[str] The title of the embed. description Optional[str] The description of the embed. color Optional[int] The color of the embed. url Optional[str] The url of the embed. timestamp Optional[datetime.datetime] The timestamp of the embed. footer Optional[lefi.EmbedFooter] The footer of the embed. image Optional[lefi.EmbedImage] The image of the embed. video Optional[lefi.EmbedVideo] The video of the embed. provider Optional[lefi.EmbedProvider] The provider of the embed. author Optional[lefi.EmbedAuthor] The author of the embed. fields Optional[List[lefi.EmbedField]] The list of fields for the embed. Note You shouldn't be creating all the classes to pass in. Rather use the set_ methods of lefi.Embed","title":"Embed"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.__init__","text":"Parameters: Name Type Description Default title Optional[str] The title of the embed. None description Optional[str] The description of the embed. None color Optional[int] The color of the embed. None url Optional[str] The url of the embed. None timestamp Optional[datetime.datetime] The timestamp of the embed. None footer Optional[lefi.EmbedFooter] The footer of the embed. None image Optional[lefi.EmbedImage] The image of the embed. None video Optional[lefi.EmbedVideo] The video of the embed. None provider Optional[lefi.EmbedProvider] The provider of the embed. None author Optional[lefi.EmbedAuthor] The author of the embed. None fields Optional[List[lefi.EmbedField]] The list of fields for the embed. None Source code in lefi/objects/embed.py def __init__ ( self , * , title : Optional [ str ] = None , description : Optional [ str ] = None , color : Optional [ int ] = None , url : Optional [ str ] = None , timestamp : Optional [ datetime . datetime ] = None , footer : Optional [ EmbedFooter ] = None , image : Optional [ EmbedImage ] = None , video : Optional [ EmbedVideo ] = None , provider : Optional [ EmbedProvider ] = None , author : Optional [ EmbedAuthor ] = None , fields : Optional [ List [ EmbedField ]] = None ) -> None : \"\"\" Parameters: title (Optional[str]): The title of the embed. description (Optional[str]): The description of the embed. color (Optional[int]): The color of the embed. url (Optional[str]): The url of the embed. timestamp (Optional[datetime.datetime]): The timestamp of the embed. footer (Optional[lefi.EmbedFooter]): The footer of the embed. image (Optional[lefi.EmbedImage]): The image of the embed. video (Optional[lefi.EmbedVideo]): The video of the embed. provider (Optional[lefi.EmbedProvider]): The provider of the embed. author (Optional[lefi.EmbedAuthor]): The author of the embed. fields (Optional[List[lefi.EmbedField]]): The list of fields for the embed. \"\"\" self . title = title self . description = description self . color = color self . url = url self . timestamp = timestamp . isoformat () if timestamp is not None else timestamp self . footer = footer self . image = image self . video = video self . provider = provider self . author = author self . fields = [] if fields is None else fields","title":"__init__()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.set_footer","text":"Sets the footer of the embed. Parameters: Name Type Description Default text str The text of the footer. required icon_url str The icon url of the footer None Source code in lefi/objects/embed.py def set_footer ( self , * , text : str , icon_url : Optional [ str ] = None ) -> Embed : \"\"\" Sets the footer of the embed. Parameters: text (str): The text of the footer. icon_url (str): The icon url of the footer \"\"\" self . footer = EmbedFooter ( text = text , icon_url = icon_url ) return self","title":"set_footer()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.set_image","text":"Sets the image of the embed. Parameters: Name Type Description Default url str The images url. required height Optional[int] The height of the image. None width Optional[int] The width of the image. None Source code in lefi/objects/embed.py def set_image ( self , * , url : str , height : Optional [ int ] = None , width : Optional [ int ] = None ) -> Embed : \"\"\" Sets the image of the embed. Parameters: url (str): The images url. height (Optional[int]): The height of the image. width (Optional[int]): The width of the image. \"\"\" self . image = EmbedImage ( url = url , height = height , width = width ) return self","title":"set_image()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.set_video","text":"Sets the video of the embed. Parameters: Name Type Description Default url str The video url. required height Optional[int] The height of the video. None width Optional[int] The width of the video. None Source code in lefi/objects/embed.py def set_video ( self , * , url : str , height : Optional [ int ] = None , width : Optional [ int ] = None ) -> Embed : \"\"\" Sets the video of the embed. Parameters: url (str): The video url. height (Optional[int]): The height of the video. width (Optional[int]): The width of the video. \"\"\" self . video = EmbedVideo ( url = url , height = height , width = width ) return self","title":"set_video()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.set_provider","text":"Sets the provider of the embed. Parameters: Name Type Description Default name Optional[str] The name of the provider. None url Optional[str] The url of the provider. None Source code in lefi/objects/embed.py def set_provider ( self , * , name : Optional [ str ] = None , url : Optional [ str ] = None ) -> Embed : \"\"\" Sets the provider of the embed. Parameters: name (Optional[str]): The name of the provider. url (Optional[str]): The url of the provider. \"\"\" self . provider = EmbedProvider ( name = name , url = url ) return self","title":"set_provider()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.set_author","text":"Sets the author of the embed. Parameters: Name Type Description Default name str The name of the author. required url Optional[str] The url of the author. None icon_url Optional[str] The icon url of the author. None Source code in lefi/objects/embed.py def set_author ( self , * , name : str , url : Optional [ str ] = None , icon_url : Optional [ str ] = None ) -> Embed : \"\"\" Sets the author of the embed. Parameters: name (str): The name of the author. url (Optional[str]): The url of the author. icon_url (Optional[str]): The icon url of the author. \"\"\" self . author = EmbedAuthor ( name = name , url = url , icon_url = icon_url ) return self","title":"set_author()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.add_field","text":"Adds a field to the embed. Parameters: Name Type Description Default name str The name of the field. required value str The vaue of the field. required inline bool Whether the field is inline or not. True Source code in lefi/objects/embed.py def add_field ( self , * , name : str , value : str , inline : bool = True ) -> Embed : \"\"\" Adds a field to the embed. Parameters: name (str): The name of the field. value (str): The vaue of the field. inline (bool): Whether the field is inline or not. \"\"\" self . fields . append ( EmbedField ( name = name , value = value , inline = inline )) return self","title":"add_field()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.Embed.to_dict","text":"Turns the embed into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the embed. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the embed into a raw dict. Returns: The dict representing the embed. \"\"\" payload : dict = {} update_payload ( payload , title = self . title , description = self . description , color = self . color , url = self . url , timestamp = self . timestamp , footer = self . _to_dict ( self . footer ), image = self . _to_dict ( self . image ), video = self . _to_dict ( self . video ), provider = self . _to_dict ( self . provider ), author = self . _to_dict ( self . author ), fields = [ field . to_dict () for field in self . fields ], ) return payload","title":"to_dict()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedAuthor","text":"Represents an Embed's author. Attributes: Name Type Description name str The name of the author. url str The url of the author. icon_url str The icon url of the author.","title":"EmbedAuthor"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedAuthor.__init__","text":"Parameters: Name Type Description Default name str The name of the author. required url Optional[str] The url of the author. None icon_url Optional[str] The icon url of the author. None Source code in lefi/objects/embed.py def __init__ ( self , * , name : str , url : Optional [ str ] = None , icon_url : Optional [ str ] = None ) -> None : \"\"\" Parameters: name (str): The name of the author. url (Optional[str]): The url of the author. icon_url (Optional[str]): The icon url of the author. \"\"\" self . name = name self . url = url self . icon_url = icon_url","title":"__init__()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedAuthor.to_dict","text":"Turns the author to a raw dict. Returns: Type Description Dict[str, Any] The dict representing the author. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the author to a raw dict. Returns: The dict representing the author. \"\"\" return update_payload ({}, name = self . name , url = self . url , icon_url = self . icon_url )","title":"to_dict()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedField","text":"Represents an Embed's field. Attributes: Name Type Description name str The name of the field. value str The value of the field. inline bool Whether the field is inline or not.","title":"EmbedField"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedField.__init__","text":"Parameters: Name Type Description Default name str The name of the field. required value str The value of the field. required inline bool Whether the field is inline or not. True Source code in lefi/objects/embed.py def __init__ ( self , * , name : str , value : str , inline : bool = True ) -> None : \"\"\" Parameters: name (str): The name of the field. value (str): The value of the field. inline (bool): Whether the field is inline or not. \"\"\" self . name = name self . value = value self . inline = inline","title":"__init__()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedField.to_dict","text":"Turns the field into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the field. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the field into a raw dict. Returns: The dict representing the field. \"\"\" return update_payload ({}, name = self . name , value = self . value , inline = self . inline )","title":"to_dict()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedFooter","text":"Represents an Embed's footer. Attributes: Name Type Description text str The content of the footer. icon_url str The icon url of the footer.","title":"EmbedFooter"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedFooter.__init__","text":"Parameters: Name Type Description Default text str The text for the footer. required icon_url Optional[str] The icon url for the footer. None Source code in lefi/objects/embed.py def __init__ ( self , * , text : str , icon_url : Optional [ str ] = None ) -> None : \"\"\" Parameters: text (str): The text for the footer. icon_url (Optional[str]): The icon url for the footer. \"\"\" self . text = text self . icon_url = icon_url","title":"__init__()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedFooter.to_dict","text":"Turns the footer into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the footer. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the footer into a raw dict. Returns: The dict representing the footer. \"\"\" payload = { \"text\" : self . text } update_payload ( payload , icon_url = self . icon_url ) return payload","title":"to_dict()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedImage","text":"Represents an Embed's image. Attributes: Name Type Description url str The image's url. height Optional[int] The height of the image. width Optional[int] The width of the image.","title":"EmbedImage"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedImage.to_dict","text":"Turns the image into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the image. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the image into a raw dict. Returns: The dict representing the image. \"\"\" payload = { \"url\" : self . url } update_payload ( payload , height = self . height , width = self . width ) return payload","title":"to_dict()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedProvider","text":"Representing an Embed's provider. Attributes: Name Type Description name str The name of the provider. url str The url of the provider.","title":"EmbedProvider"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedProvider.__init__","text":"Parameters: Name Type Description Default name str The name of the provider. None url str The url of the provider. None Source code in lefi/objects/embed.py def __init__ ( self , * , name : Optional [ str ] = None , url : Optional [ str ] = None ) -> None : \"\"\" Parameters: name (str): The name of the provider. url (str): The url of the provider. \"\"\" self . name = name self . url = url","title":"__init__()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedProvider.to_dict","text":"Turns the provider into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the provider. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the provider into a raw dict. Returns: The dict representing the provider. \"\"\" return update_payload ({}, name = self . name , url = self . url )","title":"to_dict()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedVideo","text":"Represents a Embed's video. Attributes: Name Type Description url str The videos url. height Optional[int] The height of the video. width Optional[int] The width of the video.","title":"EmbedVideo"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedVideo.__init__","text":"Parameters: Name Type Description Default url str The url of the video. required height Optional[int] The height of the video. None width Optional[int] The width of the video. None Source code in lefi/objects/embed.py def __init__ ( self , * , url : str , height : Optional [ int ] = None , width : Optional [ int ] = None ) -> None : \"\"\" Parameters: url (str): The url of the video. height (Optional[int]): The height of the video. width (Optional[int]): The width of the video. \"\"\" super () . __init__ ( url = url , height = height , width = width )","title":"__init__()"},{"location":"API-Reference/embed/#lefi.objects.embed.embed.EmbedVideo.to_dict","text":"Turns the image into a raw dict. Returns: Type Description Dict[str, Any] The dict representing the video. Source code in lefi/objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Turns the image into a raw dict. Returns: The dict representing the video. \"\"\" return update_payload ({}, ** super () . to_dict ())","title":"to_dict()"},{"location":"API-Reference/errors/","text":"BadRequest ( HTTPException ) Represents a 400 error Forbidden ( HTTPException ) Represents a 403 error HTTPException ( Exception ) Error representing an error received from the API. Attributes: Name Type Description data Union[Dict[str, Any], str] data received from the API. messsage str The message for the error. code int The code of the error. NotFound ( HTTPException ) Represents a 404 error Unauthorized ( HTTPException ) Represents a 401 error","title":"Errors"},{"location":"API-Reference/errors/#lefi.errors.BadRequest","text":"Represents a 400 error","title":"BadRequest"},{"location":"API-Reference/errors/#lefi.errors.Forbidden","text":"Represents a 403 error","title":"Forbidden"},{"location":"API-Reference/errors/#lefi.errors.HTTPException","text":"Error representing an error received from the API. Attributes: Name Type Description data Union[Dict[str, Any], str] data received from the API. messsage str The message for the error. code int The code of the error.","title":"HTTPException"},{"location":"API-Reference/errors/#lefi.errors.NotFound","text":"Represents a 404 error","title":"NotFound"},{"location":"API-Reference/errors/#lefi.errors.Unauthorized","text":"Represents a 401 error","title":"Unauthorized"},{"location":"API-Reference/http/","text":"A class used to send and handle requests to the discord API. Attributes: Name Type Description token str The clients token, used for authorization. loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop being used. session aiohttp.ClientSession The aiohttp.ClientSession to use for sending requests. Danger This class is used internally, this is not intended to be called directly . __init__ ( self , token , loop ) special Parameters: Name Type Description Default token str The token to use for authorzation. required loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop to use. required session aiohttp.ClientSession The aiohttp.ClientSession to use for sending requests. required Source code in lefi/http.py def __init__ ( self , token : str , loop : asyncio . AbstractEventLoop ) -> None : \"\"\" Parameters: token (str): The token to use for authorzation. loop (asyncio.AbstractEventLoop): The [asyncio.AbstractEventLoop][] to use. session (aiohttp.ClientSession): The [aiohttp.ClientSession][] to use for sending requests. \"\"\" self . token : str = token self . loop : asyncio . AbstractEventLoop = loop self . session : aiohttp . ClientSession = None # type: ignore request ( self , method , path , ** kwargs ) async Makes a request to the discord API. Parameters: Name Type Description Default method str The method for the request. required path str The endpoint which to send the request to. required **kwargs Any Any extra options to pass to aiohttp.ClientSession.request {} Returns: Type Description Any The data returned from the request. Source code in lefi/http.py async def request ( self , method : str , path : str , ** kwargs ) -> Any : \"\"\" Makes a request to the discord API. Parameters: method (str): The method for the request. path (str): The endpoint which to send the request to. **kwargs (Any): Any extra options to pass to [aiohttp.ClientSession.request][] Returns: The data returned from the request. Raises: [lefi.errors.HTTPException][] if any error was received from the request. \"\"\" if self . session is None or self . session . closed : self . session = await self . _create_session () url = BASE + path async with self . session . request ( method , url , ** kwargs ) as resp : try : data = await resp . json () except aiohttp . ContentTypeError : data = await resp . text () if resp . status in ( 200 , 201 , 204 , 304 ): return data if resp . status == 429 : retry_after = float ( data [ \"retry_after\" ]) # type: ignore await asyncio . sleep ( retry_after ) return await self . request ( method = method , path = path , ** kwargs ) error = self . ERRORS . get ( resp . status , HTTPException ) raise error ( data ) get_bot_gateway ( self ) async A method which gets the gateway url. Returns: Type Description Dict A dict which should contain the url. Source code in lefi/http.py async def get_bot_gateway ( self ) -> Dict : \"\"\" A method which gets the gateway url. Returns: A dict which should contain the url. \"\"\" return await self . request ( \"GET\" , \"/gateway/bot\" ) ws_connect ( self , url ) async A method which attempts to connect to the websocket. Returns: Type Description aiohttp.ClientWebSocketResponse A aiohttp.ClientWebSocketResponse instance. Source code in lefi/http.py async def ws_connect ( self , url : str ) -> aiohttp . ClientWebSocketResponse : \"\"\" A method which attempts to connect to the websocket. Returns: A [aiohttp.ClientWebSocketResponse][] instance. \"\"\" return await self . session . ws_connect ( url ) login ( self ) async Checks to see if the token given is valid. Source code in lefi/http.py async def login ( self ) -> None : \"\"\" Checks to see if the token given is valid. Raises: ValueError if an invalid token was passed. \"\"\" try : await self . request ( \"GET\" , \"/users/@me\" ) except ( Forbidden , Unauthorized ): raise ValueError ( \"Invalid token\" ) get_channel ( self , channel_id ) async Makes an API call to get a channel. Parameters: Name Type Description Default channel_id int The channel's ID. required Returns: Type Description Dict[str, Any] A dict representing the channel. Source code in lefi/http.py async def get_channel ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a channel. Parameters: channel_id (int): The channel's ID. Returns: A dict representing the channel. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } \" ) edit_text_channel ( self , channel_id , * , name = None , type = None , position = None , topic = None , nsfw = None , rate_limit_per_user = None , permission_overwrites = None , default_auto_archive_duration = None ) async Makes an API call to edit a text channel. Parameters: Name Type Description Default channel_id int The channel id representing the channel to edit. required name Optional[str] The new name for the channel. None type Optional[int] The new type for the channel. None position Optional[int] The new position for the channel. None topic Optional[str] The new topic for the channel. None nsfw Optional[bool] Whether or not the channel should be NSFW. None rate_limit_per_user Optional[int] The new slowmode of the channel. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permission overwrites for the channel. required default_auto_archive_duration Optional[List[Dict[str, Any]]] New time for threads to auto archive. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_text_channel ( self , channel_id : int , * , name : Optional [ str ] = None , type : Optional [ int ] = None , position : Optional [ int ] = None , topic : Optional [ str ] = None , nsfw : Optional [ bool ] = None , rate_limit_per_user : Optional [ int ] = None , permission_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , default_auto_archive_duration : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a text channel. Parameters: channel_id (int): The channel id representing the channel to edit. name (Optional[str]): The new name for the channel. type (Optional[int]): The new type for the channel. position (Optional[int]): The new position for the channel. topic (Optional[str]): The new topic for the channel. nsfw (Optional[bool]): Whether or not the channel should be NSFW. rate_limit_per_user (Optional[int]): The new slowmode of the channel. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permission overwrites for the channel. default_auto_archive_duration (Optional[List[Dict[str, Any]]]): New time for threads to auto archive. Returns: The data received from the API after making the call. \"\"\" payload = update_payload ( {}, name = name , type = type , position = position , topic = topic , nsfw = nsfw , rate_limit_per_user = rate_limit_per_user , permission_overwrites = permission_overwrites , default_auto_archive_duration = default_auto_archive_duration , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload ) edit_voice_channel ( self , channel_id , * , name = None , position = None , bitrate = None , user_limit = None , rtc_region = None , video_quality_mode = None , sync_permissions = None , permissions_overwrites = None ) async Makes an API call to edit a voice channel. Parameters: Name Type Description Default channel_id int The ID representing the voice channel to edit. required name Optional[str] The new name to give the channel. None position Optional[int] The new position of the channel. None bitrate Optional[int] The new bitrate of the channel. None user_limit Optional[int] The new user limit of the channel. None rtc_region Optional[str] The new rtc region of the channel. None video_quality_mode Optional[int] The new video quality of the channel. None sync_permissions Optional[bool] Whether or not to sync the permissions. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permissions ovewrites for the channel. None Returns: Type Description Dict[str, Any] The data received from the API after the call. Source code in lefi/http.py async def edit_voice_channel ( self , channel_id : int , * , name : Optional [ str ] = None , position : Optional [ int ] = None , bitrate : Optional [ int ] = None , user_limit : Optional [ int ] = None , rtc_region : Optional [ str ] = None , video_quality_mode : Optional [ int ] = None , sync_permissions : Optional [ bool ] = None , permissions_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a voice channel. Parameters: channel_id (int): The ID representing the voice channel to edit. name (Optional[str]): The new name to give the channel. position (Optional[int]): The new position of the channel. bitrate (Optional[int]): The new bitrate of the channel. user_limit (Optional[int]): The new user limit of the channel. rtc_region (Optional[str]): The new rtc region of the channel. video_quality_mode (Optional[int]): The new video quality of the channel. sync_permissions (Optional[bool]): Whether or not to sync the permissions. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permissions ovewrites for the channel. Returns: The data received from the API after the call. \"\"\" payload = update_payload ( {}, name = name , position = position , bitrate = bitrate , user_limit = user_limit , rtc_region = rtc_region , video_quality_mode = video_quality_mode , sync_permissions = sync_permissions , permissions_overwrites = permissions_overwrites , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload ) get_channel_messages ( self , channel_id , * , around = None , before = None , after = None , limit = 50 ) async Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: Name Type Description Default channel_id int The ID representing the channel. required around Optional[int] Gets messages around this message ID. None before Optional[int] Gets messages before this message ID. None after Optional[int] Gets messages after this message ID. None limit int THe amount of messages to grab. 50 Returns: Type Description Dict[str, Any] The data received after making the call. Source code in lefi/http.py async def get_channel_messages ( self , channel_id : int , * , around : Optional [ int ] = None , before : Optional [ int ] = None , after : Optional [ int ] = None , limit : int = 50 , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: channel_id (int): The ID representing the channel. around (Optional[int]): Gets messages around this message ID. before (Optional[int]): Gets messages before this message ID. after (Optional[int]): Gets messages after this message ID. limit (int): THe amount of messages to grab. Returns: The data received after making the call. \"\"\" params = { \"limit\" : limit } update_payload ( params , around = around , before = before , after = after ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages\" , params = params ) get_channel_message ( self , channel_id , message_id ) async Makes an API call to get a specific message by ID. Parameters: Name Type Description Default channel_id int The channel ID which the message is in. required message_id int The messages ID. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_channel_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a specific message by ID. Parameters: channel_id (int): The channel ID which the message is in. message_id (int): The messages ID. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages/ { message_id } \" ) send_message ( self , channel_id , content = None , * , tts = False , embeds = None , allowed_mentions = None , message_reference = None , components = None , sticker_ids = None ) async Makes an API call to send a message. Parameters: Name Type Description Default channel_id int The ID of the channel which to send the message in. required content Optional[str] The content of the message. None tts bool Whether or not to send the message with text-to-speech. False embeds Optional[List[Dict[str, Any]]] The list of embeds to send. None message_reference Optional[Dict[str, Any]] The messages to reference when sending the message. None components Optional[List[Dict[str, Any]]] The components to attach to the message. None sticker_ids Optional[List[int]] The stickers to send with the message. None Note Max embeds that can sent at a time is 10. Source code in lefi/http.py async def send_message ( self , channel_id : int , content : Optional [ str ] = None , * , tts : bool = False , embeds : Optional [ List [ Dict [ str , Any ]]] = None , allowed_mentions : Optional [ Dict [ str , Any ]] = None , message_reference : Optional [ Dict [ str , Any ]] = None , components : Optional [ List [ Dict [ str , Any ]]] = None , sticker_ids : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to send a message. Parameters: channel_id (int): The ID of the channel which to send the message in. content (Optional[str]): The content of the message. tts (bool): Whether or not to send the message with text-to-speech. embeds (Optional[List[Dict[str, Any]]]): The list of embeds to send. message_reference (Optional[Dict[str, Any]]): The messages to reference when sending the message. components (Optional[List[Dict[str, Any]]]): The components to attach to the message. sticker_ids (Optional[List[int]]): The stickers to send with the message. Note: Max embeds that can sent at a time is 10. \"\"\" payload = { \"tts\" : tts } update_payload ( payload , content = content , embeds = embeds , allowed_mentions = allowed_mentions , message_reference = message_reference , components = components , sticker_ids = sticker_ids , ) return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages\" , json = payload ) crosspost_message ( self , channel_id , message_id ) async Makes an API call to crosspost a message. Parameters: Name Type Description Default channel_id int The ID of the channel to crosspost to. required message_id int The ID of the message which to crosspost. required Returns: Type Description Dict[str, Any] The data received after making the call. Source code in lefi/http.py async def crosspost_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to crosspost a message. Parameters: channel_id (int): The ID of the channel to crosspost to. message_id (int): The ID of the message which to crosspost. Returns: The data received after making the call. \"\"\" return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages/ { message_id } /crosspost\" ) create_reaction ( self , channel_id , message_id , emoji ) async Makes an API call to add a reaction to a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message which to add the reaction to. required emoji str The emoji which to add. required Returns: Type Description The data received from the API after making the call. Source code in lefi/http.py async def create_reaction ( self , channel_id : int , message_id : int , emoji : str ): \"\"\" Makes an API call to add a reaction to a message. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message which to add the reaction to. emoji (str): The emoji which to add. Returns: The data received from the API after making the call. \"\"\" return await self . request ( method = \"PUT\" , path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } /@me\" , ) delete_reaction ( self , channel_id , message_id , emoji , user_id = None ) async Makes an API call to delete a reaction. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message. required emoji str The emoji to remove from the message's reactions. required user_id Optional[int] The ID of the user to remove from the reactions. None Returns: Type Description None The data received from the API after making the call. Note If no user_id is given it will delete the client's reaction. Source code in lefi/http.py async def delete_reaction ( self , channel_id : int , message_id : int , emoji : str , user_id : Optional [ int ] = None , ) -> None : \"\"\" Makes an API call to delete a reaction. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message. emoji (str): The emoji to remove from the message's reactions. user_id (Optional[int]): The ID of the user to remove from the reactions. Returns: The data received from the API after making the call. Note: If no user_id is given it will delete the client's reaction. \"\"\" if user_id is not None : path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } / { user_id } \" else : path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } /@me\" await self . request ( \"DELETE\" , path ) get_reactions ( self , channel_id , message_id , emoji , * , after = None , limit = 25 ) async Makes an API call to get a list of users who reacted to a message.. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message. required emoji str The emoji from which to grab users from. required after int Grab users after this user ID. None limit int The max amount of users to grab. 25 Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_reactions ( self , channel_id : int , message_id : int , emoji : str , * , after : Optional [ int ] = None , limit : int = 25 , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of users who reacted to a message.. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message. emoji (str): The emoji from which to grab users from. after (int): Grab users after this user ID. limit (int): The max amount of users to grab. Returns: The data received from the API after making the call. \"\"\" params = { \"limit\" : limit } update_payload ( params , after = after ) return await self . request ( method = \"GET\" , path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } \" , params = params , ) delete_all_reactions ( self , channel_id , message_id , emoji ) async Makes an API call to remove all reactions of a message. Parameters: Name Type Description Default channel_id int The channel which the target message is in. required message_id int The ID of the message. required emoji str The reaction to remove. required Returns: Type Description Dict[str, Any] The data received from the API After making the call. Source code in lefi/http.py async def delete_all_reactions ( self , channel_id : int , message_id : int , emoji : str ) -> Dict [ str , Any ]: \"\"\" Makes an API call to remove all reactions of a message. Parameters: channel_id (int): The channel which the target message is in. message_id (int): The ID of the message. emoji (str): The reaction to remove. Returns: The data received from the API After making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } \" ) edit_message ( self , channel_id , message_id , * , content = None , embeds = None , flags = None , allowed_mentions = None , attachments = None , components = None ) async Makes an API call to edit a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message. required content Optional[str] The new content of the message. None embeds Optional[List[Dict[str, Any]]] The new embeds of the message. None flags Optional[int] The new flags of the message. None allowed_mentions Optional[int] The new allowed mentions of the message. None attachments Optional[List[Dict[str, Any]]] The new attachments of the message. None components Optional[List[Dict[str, Any]]] The new components of the message. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_message ( self , channel_id : int , message_id : int , * , content : Optional [ str ] = None , embeds : Optional [ List [ Dict [ str , Any ]]] = None , flags : Optional [ int ] = None , allowed_mentions : Optional [ Dict [ str , Any ]] = None , attachments : Optional [ List [ Dict [ str , Any ]]] = None , components : Optional [ List [ Dict [ str , Any ]]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a message. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message. content (Optional[str]): The new content of the message. embeds (Optional[List[Dict[str, Any]]]): The new embeds of the message. flags (Optional[int]): The new flags of the message. allowed_mentions (Optional[int]): The new allowed mentions of the message. attachments (Optional[List[Dict[str, Any]]]): The new attachments of the message. components (Optional[List[Dict[str, Any]]]): The new components of the message. Returns: The data received from the API after making the call. \"\"\" payload : dict = {} update_payload ( payload , content = content , embeds = embeds , flags = flags , allowed_mentions = allowed_mentions , attachments = attachments , components = components , ) return await self . request ( method = \"PATCH\" , path = f \"/channels/ { channel_id } /messages/ { message_id } \" , ) delete_message ( self , channel_id , message_id ) async Makes an API call to delete a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the message is in. required message_id int The ID Of the message. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to delete a message. Parameters: channel_id (int): The ID of the channel which the message is in. message_id (int): The ID Of the message. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } \" ) bulk_delete_messages ( self , channel_id , message_ids ) async Makes an API call to delete multiple messages. Parameters: Name Type Description Default channel_id int The ID of the channel which the message is in. required message_ids List[int] The list of ID's representing messages of which to delete. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def bulk_delete_messages ( self , channel_id : int , message_ids : List [ int ]) -> Dict [ str , Any ]: \"\"\" Makes an API call to delete multiple messages. Parameters: channel_id (int): The ID of the channel which the message is in. message_ids (List[int]): The list of ID's representing messages of which to delete. Returns: The data received from the API after making the call. \"\"\" payload = { \"messages\" : message_ids } return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages/bulk-delete\" , json = payload ) edit_channel_permissions ( self , channel_id , overwrite_id , * , allow = None , deny = None , type = None ) async Makes an API call to edit a channels permissions. Parameters: Name Type Description Default channel_id int The ID of the channel. required overwrite_id int The ID of the overwrite. required allow Optional[int] The bitwise value of all allowed permissions. None deny Optional[int] The bitwise value of all denied permissison. None type Optional[int] The type, 0 being a role and 1 being a member. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_channel_permissions ( self , channel_id : int , overwrite_id : int , * , allow : Optional [ int ] = None , deny : Optional [ int ] = None , type : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a channels permissions. Parameters: channel_id (int): The ID of the channel. overwrite_id (int): The ID of the overwrite. allow (Optional[int]): The bitwise value of all allowed permissions. deny (Optional[int]): The bitwise value of all denied permissison. type (Optional[int]): The type, 0 being a role and 1 being a member. Returns: The data received from the API after making the call. \"\"\" payload : dict = {} update_payload ( payload , allow = allow , deny = deny , type = type ) return await self . request ( method = \"PUT\" , path = f \"/channels/ { channel_id } /permissions/ { overwrite_id } \" , json = payload , ) delete_channel_permissions ( self , channel_id , overwrite_id ) async Makes an API call to delete an overwrite from a channel. Parameters: Name Type Description Default channel_id int The ID of the channel. required overwrite_id int The ID of the overwrite. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_channel_permissions ( self , channel_id : int , overwrite_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to delete an overwrite from a channel. Parameters: channel_id (int): The ID of the channel. overwrite_id (int): The ID of the overwrite. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /permissions/ { overwrite_id } \" ) get_channel_invites ( self , channel_id ) async Makes an API call to get a channels invites. Parameters: Name Type Description Default channel_id int The ID of the channel. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_channel_invites ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a channels invites. Parameters: channel_id (int): The ID of the channel. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /invites\" ) create_channel_invite ( self , channel_id , * , max_age = 86400 , max_uses = 0 , temporary = False , unique = False , target_type = None , target_user_id = None , target_application_id = None ) async Makes an API call to create an invite. Parameters: Name Type Description Default channel_id int The ID of the channel. required max_age int The max age of the invite. 86400 max_uses int The max uses of the invite. 0 if unlimited. 0 temporary bool Whether or not the invite is temporary. False unique bool Whether or not the invite is unique. False target_type Optional[int] The type of the invite. For voice channels. None target_user_id Optional[int] The ID of the user whose stream to invite to. For voice channels. None target_application_id Optional[int] The ID of embedded application to invite from. For target type 2. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def create_channel_invite ( self , channel_id : int , * , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ int ] = None , target_user_id : Optional [ int ] = None , target_application_id : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to create an invite. Parameters: channel_id (int): The ID of the channel. max_age (int): The max age of the invite. max_uses (int): The max uses of the invite. 0 if unlimited. temporary (bool): Whether or not the invite is temporary. unique (bool): Whether or not the invite is unique. target_type (Optional[int]): The type of the invite. For voice channels. target_user_id (Optional[int]): The ID of the user whose stream to invite to. For voice channels. target_application_id (Optional[int]): The ID of embedded application to invite from. For target type 2. Returns: The data received from the API after making the call. \"\"\" payload = { \"max_age\" : max_age , \"max_uses\" : max_uses , \"temporary\" : temporary , \"unique\" : unique , } update_payload ( payload , target_type = target_type , target_user_id = target_user_id , target_application_id = target_application_id , ) return await self . request ( \"POST\" , f \"/channels/ { channel_id } /invites\" , json = payload ) follow_news_channel ( self , channel_id , webhook_channel_id ) async Makes an API call to follow a news channel to send messages to a target channel. Parameters: Name Type Description Default channel_id int The ID Of the channel. required webhook_channel_id int The target channel. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def follow_news_channel ( self , channel_id : int , webhook_channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to follow a news channel to send messages to a target channel. Parameters: channel_id (int): The ID Of the channel. webhook_channel_id (int): The target channel. Returns: The data received from the API after making the call. \"\"\" payload = { \"webhook_channel_id\" : webhook_channel_id } return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /followers/@me\" , json = payload ) trigger_typing ( self , channel_id ) async Makes an API call to trigger typing. Parameters: Name Type Description Default channel_id int The ID of the channel which to trigger typing in. required Returns: Type Description Dict[str, Any] The data received from the API After making the call. Source code in lefi/http.py async def trigger_typing ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to trigger typing. Parameters: channel_id (int): The ID of the channel which to trigger typing in. Returns: The data received from the API After making the call. \"\"\" return await self . request ( \"POST\" , f \"/channels/ { channel_id } /typing\" ) get_pinned_messages ( self , channel_id ) async Makes an API call to get the pinned messages of a channel. Parameters: Name Type Description Default channel_id int The ID of the channel which to grab pinned messages from. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_pinned_messages ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get the pinned messages of a channel. Parameters: channel_id (int): The ID of the channel which to grab pinned messages from. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /pins\" ) pin_message ( self , channel_id , message_id ) async Makes an API call to pin a message. Parameters: Name Type Description Default channel_id int The ID of the channel where the message is. required message_id int The ID of the message. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def pin_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to pin a message. Parameters: channel_id (int): The ID of the channel where the message is. message_id (int): The ID of the message. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /pins/ { message_id } \" ) unpin_message ( self , channel_id , message_id ) async Makes an API call to unpin a message. Parameters: Name Type Description Default channel_id int The ID Of the channel where the message is. required message_id int The ID of the message. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def unpin_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to unpin a message. Parameters: channel_id (int): The ID Of the channel where the message is. message_id (int): The ID of the message. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /pins/ { message_id } \" ) start_thread_with_message ( self , channel_id , message_id , * , name , auto_archive_duration ) async Makes an API call to start a thread with a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the message is in. required message_id int The ID Of the message. required name str The name of the thread. required auto_archive_duration int The time it takes to auto archive the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def start_thread_with_message ( self , channel_id : int , message_id : int , * , name : str , auto_archive_duration : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to start a thread with a message. Parameters: channel_id (int): The ID of the channel which the message is in. message_id (int): The ID Of the message. name (str): The name of the thread. auto_archive_duration (int): The time it takes to auto archive the thread. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , \"auto_archive_duration\" : auto_archive_duration } return await self . request ( method = \"POST\" , path = f \"/channels/ { channel_id } /messages/ { message_id } /threads\" , json = payload , ) start_thread_without_message ( self , channel_id , * , name , auto_archive_duration , type = None , invitable = None ) async Makes an API call to start a thread without a message. Parameters: Name Type Description Default channel_id int The ID of the channel where the thread will be created. required name str The name of the thread. required auto_archive_duration int The time it takes to auto archive the thread. required type int The type of the thread to create. None invitable bool Whether or not members can invite other members to the thread. Only in private threads. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def start_thread_without_message ( self , channel_id : int , * , name : str , auto_archive_duration : int , type : Optional [ int ] = None , invitable : Optional [ bool ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to start a thread without a message. Parameters: channel_id (int): The ID of the channel where the thread will be created. name (str): The name of the thread. auto_archive_duration (int): The time it takes to auto archive the thread. type (int): The type of the thread to create. invitable (bool): Whether or not members can invite other members to the thread. Only in private threads. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , \"auto_archive_duration\" : auto_archive_duration } update_payload ( payload , type = type , invitable = invitable ) return await self . request ( method = \"POST\" , path = f \"/channels/ { channel_id } /threads\" , json = payload ) join_thread ( self , channel_id ) async Makes an API call which makes the client join the given thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def join_thread ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which makes the client join the given thread. Parameters: channel_id (int): The ID of the thread. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /thread-members/@me\" ) add_thread_member ( self , channel_id , user_id ) async Makes an API call which adds another member to the thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required user_id int The ID of the user to add. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def add_thread_member ( self , channel_id : int , user_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which adds another member to the thread. Parameters: channel_id (int): The ID of the thread. user_id (int): The ID of the user to add. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /thread-members/ { user_id } \" ) leave_thread ( self , channel_id ) async Makes an API call which makes the client leave the thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def leave_thread ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which makes the client leave the thread. Parameters: channel_id (int): The ID of the thread. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /thread-members/@me\" ) remove_thread_member ( self , channel_id , user_id ) async Makes an API call which removes a member from the thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required user_id int The ID of the user to remove. required Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def remove_thread_member ( self , channel_id : int , user_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which removes a member from the thread. Parameters: channel_id (int): The ID of the thread. user_id (int): The ID of the user to remove. Returns: The data received from the API after making the call \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /thread-members/ { user_id } \" ) list_thread_members ( self , channel_id ) async Makes an API call to get all of the members of a thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def list_thread_members ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get all of the members of a thread. Parameters: channel_id (int): The ID of the thread. Returns: The data received from the API after making the call \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /thread-members\" ) list_public_archived_threads ( self , channel_id , * , before = None , limit = None ) async Makes an API call which list all the public archived threads in the channel. Parameters: Name Type Description Default channel_id int The ID of the channel which the threads are inside of. required before Optional[int] Grab threads before this time. None limit Optional[int] The amount of threads to grab. None Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def list_public_archived_threads ( self , channel_id : int , * , before : Optional [ int ] = None , limit : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call which list all the public archived threads in the channel. Parameters: channel_id (int): The ID of the channel which the threads are inside of. before (Optional[int]): Grab threads before this time. limit (Optional[int]): The amount of threads to grab. Returns: The data received from the API after making the call \"\"\" params = update_payload ({}, before = before , limit = limit ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/public\" , params = params ) list_private_archived_threads ( self , channel_id , * , before = None , limit = None ) async Makes an API call which list all the private archived threads in the channel. Parameters: Name Type Description Default channel_id int The ID of the channel which the threads are inside of. required before Optional[int] Grab threads before this time. None limit Optional[int] The amount of threads to grab. None Returns: Type Description The data received from the API after making the call Source code in lefi/http.py async def list_private_archived_threads ( self , channel_id : int , * , before : Optional [ int ] = None , limit : Optional [ int ] = None , ): \"\"\" Makes an API call which list all the private archived threads in the channel. Parameters: channel_id (int): The ID of the channel which the threads are inside of. before (Optional[int]): Grab threads before this time. limit (Optional[int]): The amount of threads to grab. Returns: The data received from the API after making the call \"\"\" params = update_payload ({}, before = before , limit = limit ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/private\" , params = params ) list_joined_private_archived_threads ( self , channel_id , * , before = None , limit = None ) async Makes an API call which list all the private archived threads in the channel which the client has joined. Parameters: Name Type Description Default channel_id int The ID of the channel which the threads are inside of. required before Optional[int] Grab threads before this time. None limit Optional[int] The amount of threads to grab. None Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def list_joined_private_archived_threads ( self , channel_id : int , * , before : Optional [ int ] = None , limit : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call which list all the private archived threads in the channel which the client has joined. Parameters: channel_id (int): The ID of the channel which the threads are inside of. before (Optional[int]): Grab threads before this time. limit (Optional[int]): The amount of threads to grab. Returns: The data received from the API after making the call \"\"\" params = update_payload ({}, before = before , limit = limit ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /users/@me/threads/archived/private\" , params = params , ) list_guild_emojis ( self , guild_id ) async Makes an API call to get a list of the guilds emojis. Parameters: Name Type Description Default guild_id int The ID of the guild to grab from. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def list_guild_emojis ( self , guild_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of the guilds emojis. Parameters: guild_id (int): The ID of the guild to grab from. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/guilds/ { guild_id } /emojis\" ) get_guild_emoji ( self , guild_id , emoji_id ) async Makes an API call to get an emoji from the guild. Parameters: Name Type Description Default guild_id int The ID of the guild to grab from. required emoji_id int The ID of the emoji to get. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_guild_emoji ( self , guild_id : int , emoji_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get an emoji from the guild. Parameters: guild_id (int): The ID of the guild to grab from. emoji_id (int): The ID of the emoji to get. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" ) create_guild_emoji ( self , guild_id , * , name , image , roles = None ) async Makes an API call to create an emoji. Parameters: Name Type Description Default guild_id int The ID of the guild to create the emoji in. required name str The name of the emoji. required image str The image of the emoji. required roles Optional[List[int]] The list of roles that can use this emoji. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def create_guild_emoji ( self , guild_id : int , * , name : str , image : str , roles : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to create an emoji. Parameters: guild_id (int): The ID of the guild to create the emoji in. name (str): The name of the emoji. image (str): The image of the emoji. roles (Optional[List[int]]): The list of roles that can use this emoji. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , \"image\" : image , \"roles\" : [] if roles is None else roles , } return await self . request ( method = \"POST\" , path = f \"/guilds/ { guild_id } /emojis\" , json = payload ) modify_guild_emoji ( self , guild_id , emoji_id , * , name , roles = None ) async Makes an API call to edit an emoji. Parameters: Name Type Description Default guild_id int The ID of the guild where the emoji is. required emoji_id int The ID of the emoji. required name str The new name of the emoji. required roles Optional[List[int]] The new list of roles that can use this emoji. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def modify_guild_emoji ( self , guild_id : int , emoji_id : int , * , name : str , roles : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit an emoji. Parameters: guild_id (int): The ID of the guild where the emoji is. emoji_id (int): The ID of the emoji. name (str): The new name of the emoji. roles (Optional[List[int]]): The new list of roles that can use this emoji. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , } update_payload ( payload , roles = roles ) return await self . request ( method = \"PATCH\" , path = f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" , json = payload ) delete_guild_emoji ( self , guild_id , emoji_id ) async Makes an API call which deletes an emoji. Parameters: Name Type Description Default guild_id int The ID of the guild where the emoji is in. required emoji_id int The ID of the emoji to delete. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_guild_emoji ( self , guild_id : int , emoji_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which deletes an emoji. Parameters: guild_id (int): The ID of the guild where the emoji is in. emoji_id (int): The ID of the emoji to delete. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" ) create_dm_channel ( self , recipient_id ) async Makes an API call which creates a DM channel to a user. Parameters: Name Type Description Default recipient_id int The ID of the user which to open the DM channel to. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def create_dm_channel ( self , recipient_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which creates a DM channel to a user. Parameters: recipient_id (int): The ID of the user which to open the DM channel to. Returns: The data received from the API after making the call. \"\"\" payload = { \"recipient_id\" : recipient_id } return await self . request ( \"POST\" , \"/users/@me/channels\" , json = payload ) modifiy_guild_role ( self , guild_id , role_id , * , name = None , permissions = None , color = None , hoist = None , mentionable = None ) async Makes an API call which edits a role. Parameters: Name Type Description Default guild_id int The ID of the guild where the role is. required role_id int The ID of the role. required name Optional[str] The new name of the role. None permissions Optional[int] The new permissions of the role. None color Optional[int] The new color of the role. None hoist Optional[bool] Whether or not to hoist the role. None mentionable Optional[bool] Whether or not the role should be mentionable. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def modifiy_guild_role ( self , guild_id : int , role_id : int , * , name : Optional [ str ] = None , permissions : Optional [ int ] = None , color : Optional [ int ] = None , hoist : Optional [ bool ] = None , mentionable : Optional [ bool ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call which edits a role. Parameters: guild_id (int): The ID of the guild where the role is. role_id (int): The ID of the role. name (Optional[str]): The new name of the role. permissions (Optional[int]): The new permissions of the role. color (Optional[int]): The new color of the role. hoist (Optional[bool]): Whether or not to hoist the role. mentionable (Optional[bool]): Whether or not the role should be mentionable. Returns: The data received from the API after making the call. \"\"\" payload = update_payload ( {}, name = name , permissions = permissions , color = color , hoist = hoist , mentionable = mentionable , ) return await self . request ( method = \"PATCH\" , path = f \"/guilds/ { guild_id } /roles/ { role_id } \" , json = payload ) delete_guild_role ( self , guild_id , role_id ) async Makes an API call which deletes a role. Parameters: Name Type Description Default guild_id int The ID of the guild where the role is. required role_id int The ID of the role. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_guild_role ( self , guild_id : int , role_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which deletes a role. Parameters: guild_id (int): The ID of the guild where the role is. role_id (int): The ID of the role. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/guilds/ { guild_id } /roles/ { role_id } \" )","title":"HTTPClient"},{"location":"API-Reference/http/#lefi.http.HTTPClient.__init__","text":"Parameters: Name Type Description Default token str The token to use for authorzation. required loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop to use. required session aiohttp.ClientSession The aiohttp.ClientSession to use for sending requests. required Source code in lefi/http.py def __init__ ( self , token : str , loop : asyncio . AbstractEventLoop ) -> None : \"\"\" Parameters: token (str): The token to use for authorzation. loop (asyncio.AbstractEventLoop): The [asyncio.AbstractEventLoop][] to use. session (aiohttp.ClientSession): The [aiohttp.ClientSession][] to use for sending requests. \"\"\" self . token : str = token self . loop : asyncio . AbstractEventLoop = loop self . session : aiohttp . ClientSession = None # type: ignore","title":"__init__()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.request","text":"Makes a request to the discord API. Parameters: Name Type Description Default method str The method for the request. required path str The endpoint which to send the request to. required **kwargs Any Any extra options to pass to aiohttp.ClientSession.request {} Returns: Type Description Any The data returned from the request. Source code in lefi/http.py async def request ( self , method : str , path : str , ** kwargs ) -> Any : \"\"\" Makes a request to the discord API. Parameters: method (str): The method for the request. path (str): The endpoint which to send the request to. **kwargs (Any): Any extra options to pass to [aiohttp.ClientSession.request][] Returns: The data returned from the request. Raises: [lefi.errors.HTTPException][] if any error was received from the request. \"\"\" if self . session is None or self . session . closed : self . session = await self . _create_session () url = BASE + path async with self . session . request ( method , url , ** kwargs ) as resp : try : data = await resp . json () except aiohttp . ContentTypeError : data = await resp . text () if resp . status in ( 200 , 201 , 204 , 304 ): return data if resp . status == 429 : retry_after = float ( data [ \"retry_after\" ]) # type: ignore await asyncio . sleep ( retry_after ) return await self . request ( method = method , path = path , ** kwargs ) error = self . ERRORS . get ( resp . status , HTTPException ) raise error ( data )","title":"request()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_bot_gateway","text":"A method which gets the gateway url. Returns: Type Description Dict A dict which should contain the url. Source code in lefi/http.py async def get_bot_gateway ( self ) -> Dict : \"\"\" A method which gets the gateway url. Returns: A dict which should contain the url. \"\"\" return await self . request ( \"GET\" , \"/gateway/bot\" )","title":"get_bot_gateway()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.ws_connect","text":"A method which attempts to connect to the websocket. Returns: Type Description aiohttp.ClientWebSocketResponse A aiohttp.ClientWebSocketResponse instance. Source code in lefi/http.py async def ws_connect ( self , url : str ) -> aiohttp . ClientWebSocketResponse : \"\"\" A method which attempts to connect to the websocket. Returns: A [aiohttp.ClientWebSocketResponse][] instance. \"\"\" return await self . session . ws_connect ( url )","title":"ws_connect()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.login","text":"Checks to see if the token given is valid. Source code in lefi/http.py async def login ( self ) -> None : \"\"\" Checks to see if the token given is valid. Raises: ValueError if an invalid token was passed. \"\"\" try : await self . request ( \"GET\" , \"/users/@me\" ) except ( Forbidden , Unauthorized ): raise ValueError ( \"Invalid token\" )","title":"login()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_channel","text":"Makes an API call to get a channel. Parameters: Name Type Description Default channel_id int The channel's ID. required Returns: Type Description Dict[str, Any] A dict representing the channel. Source code in lefi/http.py async def get_channel ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a channel. Parameters: channel_id (int): The channel's ID. Returns: A dict representing the channel. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } \" )","title":"get_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.edit_text_channel","text":"Makes an API call to edit a text channel. Parameters: Name Type Description Default channel_id int The channel id representing the channel to edit. required name Optional[str] The new name for the channel. None type Optional[int] The new type for the channel. None position Optional[int] The new position for the channel. None topic Optional[str] The new topic for the channel. None nsfw Optional[bool] Whether or not the channel should be NSFW. None rate_limit_per_user Optional[int] The new slowmode of the channel. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permission overwrites for the channel. required default_auto_archive_duration Optional[List[Dict[str, Any]]] New time for threads to auto archive. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_text_channel ( self , channel_id : int , * , name : Optional [ str ] = None , type : Optional [ int ] = None , position : Optional [ int ] = None , topic : Optional [ str ] = None , nsfw : Optional [ bool ] = None , rate_limit_per_user : Optional [ int ] = None , permission_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , default_auto_archive_duration : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a text channel. Parameters: channel_id (int): The channel id representing the channel to edit. name (Optional[str]): The new name for the channel. type (Optional[int]): The new type for the channel. position (Optional[int]): The new position for the channel. topic (Optional[str]): The new topic for the channel. nsfw (Optional[bool]): Whether or not the channel should be NSFW. rate_limit_per_user (Optional[int]): The new slowmode of the channel. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permission overwrites for the channel. default_auto_archive_duration (Optional[List[Dict[str, Any]]]): New time for threads to auto archive. Returns: The data received from the API after making the call. \"\"\" payload = update_payload ( {}, name = name , type = type , position = position , topic = topic , nsfw = nsfw , rate_limit_per_user = rate_limit_per_user , permission_overwrites = permission_overwrites , default_auto_archive_duration = default_auto_archive_duration , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload )","title":"edit_text_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.edit_voice_channel","text":"Makes an API call to edit a voice channel. Parameters: Name Type Description Default channel_id int The ID representing the voice channel to edit. required name Optional[str] The new name to give the channel. None position Optional[int] The new position of the channel. None bitrate Optional[int] The new bitrate of the channel. None user_limit Optional[int] The new user limit of the channel. None rtc_region Optional[str] The new rtc region of the channel. None video_quality_mode Optional[int] The new video quality of the channel. None sync_permissions Optional[bool] Whether or not to sync the permissions. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permissions ovewrites for the channel. None Returns: Type Description Dict[str, Any] The data received from the API after the call. Source code in lefi/http.py async def edit_voice_channel ( self , channel_id : int , * , name : Optional [ str ] = None , position : Optional [ int ] = None , bitrate : Optional [ int ] = None , user_limit : Optional [ int ] = None , rtc_region : Optional [ str ] = None , video_quality_mode : Optional [ int ] = None , sync_permissions : Optional [ bool ] = None , permissions_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a voice channel. Parameters: channel_id (int): The ID representing the voice channel to edit. name (Optional[str]): The new name to give the channel. position (Optional[int]): The new position of the channel. bitrate (Optional[int]): The new bitrate of the channel. user_limit (Optional[int]): The new user limit of the channel. rtc_region (Optional[str]): The new rtc region of the channel. video_quality_mode (Optional[int]): The new video quality of the channel. sync_permissions (Optional[bool]): Whether or not to sync the permissions. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permissions ovewrites for the channel. Returns: The data received from the API after the call. \"\"\" payload = update_payload ( {}, name = name , position = position , bitrate = bitrate , user_limit = user_limit , rtc_region = rtc_region , video_quality_mode = video_quality_mode , sync_permissions = sync_permissions , permissions_overwrites = permissions_overwrites , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload )","title":"edit_voice_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_channel_messages","text":"Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: Name Type Description Default channel_id int The ID representing the channel. required around Optional[int] Gets messages around this message ID. None before Optional[int] Gets messages before this message ID. None after Optional[int] Gets messages after this message ID. None limit int THe amount of messages to grab. 50 Returns: Type Description Dict[str, Any] The data received after making the call. Source code in lefi/http.py async def get_channel_messages ( self , channel_id : int , * , around : Optional [ int ] = None , before : Optional [ int ] = None , after : Optional [ int ] = None , limit : int = 50 , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: channel_id (int): The ID representing the channel. around (Optional[int]): Gets messages around this message ID. before (Optional[int]): Gets messages before this message ID. after (Optional[int]): Gets messages after this message ID. limit (int): THe amount of messages to grab. Returns: The data received after making the call. \"\"\" params = { \"limit\" : limit } update_payload ( params , around = around , before = before , after = after ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages\" , params = params )","title":"get_channel_messages()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_channel_message","text":"Makes an API call to get a specific message by ID. Parameters: Name Type Description Default channel_id int The channel ID which the message is in. required message_id int The messages ID. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_channel_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a specific message by ID. Parameters: channel_id (int): The channel ID which the message is in. message_id (int): The messages ID. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages/ { message_id } \" )","title":"get_channel_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.send_message","text":"Makes an API call to send a message. Parameters: Name Type Description Default channel_id int The ID of the channel which to send the message in. required content Optional[str] The content of the message. None tts bool Whether or not to send the message with text-to-speech. False embeds Optional[List[Dict[str, Any]]] The list of embeds to send. None message_reference Optional[Dict[str, Any]] The messages to reference when sending the message. None components Optional[List[Dict[str, Any]]] The components to attach to the message. None sticker_ids Optional[List[int]] The stickers to send with the message. None Note Max embeds that can sent at a time is 10. Source code in lefi/http.py async def send_message ( self , channel_id : int , content : Optional [ str ] = None , * , tts : bool = False , embeds : Optional [ List [ Dict [ str , Any ]]] = None , allowed_mentions : Optional [ Dict [ str , Any ]] = None , message_reference : Optional [ Dict [ str , Any ]] = None , components : Optional [ List [ Dict [ str , Any ]]] = None , sticker_ids : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to send a message. Parameters: channel_id (int): The ID of the channel which to send the message in. content (Optional[str]): The content of the message. tts (bool): Whether or not to send the message with text-to-speech. embeds (Optional[List[Dict[str, Any]]]): The list of embeds to send. message_reference (Optional[Dict[str, Any]]): The messages to reference when sending the message. components (Optional[List[Dict[str, Any]]]): The components to attach to the message. sticker_ids (Optional[List[int]]): The stickers to send with the message. Note: Max embeds that can sent at a time is 10. \"\"\" payload = { \"tts\" : tts } update_payload ( payload , content = content , embeds = embeds , allowed_mentions = allowed_mentions , message_reference = message_reference , components = components , sticker_ids = sticker_ids , ) return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages\" , json = payload )","title":"send_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.crosspost_message","text":"Makes an API call to crosspost a message. Parameters: Name Type Description Default channel_id int The ID of the channel to crosspost to. required message_id int The ID of the message which to crosspost. required Returns: Type Description Dict[str, Any] The data received after making the call. Source code in lefi/http.py async def crosspost_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to crosspost a message. Parameters: channel_id (int): The ID of the channel to crosspost to. message_id (int): The ID of the message which to crosspost. Returns: The data received after making the call. \"\"\" return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages/ { message_id } /crosspost\" )","title":"crosspost_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.create_reaction","text":"Makes an API call to add a reaction to a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message which to add the reaction to. required emoji str The emoji which to add. required Returns: Type Description The data received from the API after making the call. Source code in lefi/http.py async def create_reaction ( self , channel_id : int , message_id : int , emoji : str ): \"\"\" Makes an API call to add a reaction to a message. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message which to add the reaction to. emoji (str): The emoji which to add. Returns: The data received from the API after making the call. \"\"\" return await self . request ( method = \"PUT\" , path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } /@me\" , )","title":"create_reaction()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.delete_reaction","text":"Makes an API call to delete a reaction. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message. required emoji str The emoji to remove from the message's reactions. required user_id Optional[int] The ID of the user to remove from the reactions. None Returns: Type Description None The data received from the API after making the call. Note If no user_id is given it will delete the client's reaction. Source code in lefi/http.py async def delete_reaction ( self , channel_id : int , message_id : int , emoji : str , user_id : Optional [ int ] = None , ) -> None : \"\"\" Makes an API call to delete a reaction. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message. emoji (str): The emoji to remove from the message's reactions. user_id (Optional[int]): The ID of the user to remove from the reactions. Returns: The data received from the API after making the call. Note: If no user_id is given it will delete the client's reaction. \"\"\" if user_id is not None : path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } / { user_id } \" else : path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } /@me\" await self . request ( \"DELETE\" , path )","title":"delete_reaction()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_reactions","text":"Makes an API call to get a list of users who reacted to a message.. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message. required emoji str The emoji from which to grab users from. required after int Grab users after this user ID. None limit int The max amount of users to grab. 25 Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_reactions ( self , channel_id : int , message_id : int , emoji : str , * , after : Optional [ int ] = None , limit : int = 25 , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of users who reacted to a message.. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message. emoji (str): The emoji from which to grab users from. after (int): Grab users after this user ID. limit (int): The max amount of users to grab. Returns: The data received from the API after making the call. \"\"\" params = { \"limit\" : limit } update_payload ( params , after = after ) return await self . request ( method = \"GET\" , path = f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } \" , params = params , )","title":"get_reactions()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.delete_all_reactions","text":"Makes an API call to remove all reactions of a message. Parameters: Name Type Description Default channel_id int The channel which the target message is in. required message_id int The ID of the message. required emoji str The reaction to remove. required Returns: Type Description Dict[str, Any] The data received from the API After making the call. Source code in lefi/http.py async def delete_all_reactions ( self , channel_id : int , message_id : int , emoji : str ) -> Dict [ str , Any ]: \"\"\" Makes an API call to remove all reactions of a message. Parameters: channel_id (int): The channel which the target message is in. message_id (int): The ID of the message. emoji (str): The reaction to remove. Returns: The data received from the API After making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } /reactions/ { emoji } \" )","title":"delete_all_reactions()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.edit_message","text":"Makes an API call to edit a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the target message is in. required message_id int The ID of the message. required content Optional[str] The new content of the message. None embeds Optional[List[Dict[str, Any]]] The new embeds of the message. None flags Optional[int] The new flags of the message. None allowed_mentions Optional[int] The new allowed mentions of the message. None attachments Optional[List[Dict[str, Any]]] The new attachments of the message. None components Optional[List[Dict[str, Any]]] The new components of the message. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_message ( self , channel_id : int , message_id : int , * , content : Optional [ str ] = None , embeds : Optional [ List [ Dict [ str , Any ]]] = None , flags : Optional [ int ] = None , allowed_mentions : Optional [ Dict [ str , Any ]] = None , attachments : Optional [ List [ Dict [ str , Any ]]] = None , components : Optional [ List [ Dict [ str , Any ]]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a message. Parameters: channel_id (int): The ID of the channel which the target message is in. message_id (int): The ID of the message. content (Optional[str]): The new content of the message. embeds (Optional[List[Dict[str, Any]]]): The new embeds of the message. flags (Optional[int]): The new flags of the message. allowed_mentions (Optional[int]): The new allowed mentions of the message. attachments (Optional[List[Dict[str, Any]]]): The new attachments of the message. components (Optional[List[Dict[str, Any]]]): The new components of the message. Returns: The data received from the API after making the call. \"\"\" payload : dict = {} update_payload ( payload , content = content , embeds = embeds , flags = flags , allowed_mentions = allowed_mentions , attachments = attachments , components = components , ) return await self . request ( method = \"PATCH\" , path = f \"/channels/ { channel_id } /messages/ { message_id } \" , )","title":"edit_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.delete_message","text":"Makes an API call to delete a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the message is in. required message_id int The ID Of the message. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to delete a message. Parameters: channel_id (int): The ID of the channel which the message is in. message_id (int): The ID Of the message. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } \" )","title":"delete_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.bulk_delete_messages","text":"Makes an API call to delete multiple messages. Parameters: Name Type Description Default channel_id int The ID of the channel which the message is in. required message_ids List[int] The list of ID's representing messages of which to delete. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def bulk_delete_messages ( self , channel_id : int , message_ids : List [ int ]) -> Dict [ str , Any ]: \"\"\" Makes an API call to delete multiple messages. Parameters: channel_id (int): The ID of the channel which the message is in. message_ids (List[int]): The list of ID's representing messages of which to delete. Returns: The data received from the API after making the call. \"\"\" payload = { \"messages\" : message_ids } return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages/bulk-delete\" , json = payload )","title":"bulk_delete_messages()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.edit_channel_permissions","text":"Makes an API call to edit a channels permissions. Parameters: Name Type Description Default channel_id int The ID of the channel. required overwrite_id int The ID of the overwrite. required allow Optional[int] The bitwise value of all allowed permissions. None deny Optional[int] The bitwise value of all denied permissison. None type Optional[int] The type, 0 being a role and 1 being a member. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_channel_permissions ( self , channel_id : int , overwrite_id : int , * , allow : Optional [ int ] = None , deny : Optional [ int ] = None , type : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a channels permissions. Parameters: channel_id (int): The ID of the channel. overwrite_id (int): The ID of the overwrite. allow (Optional[int]): The bitwise value of all allowed permissions. deny (Optional[int]): The bitwise value of all denied permissison. type (Optional[int]): The type, 0 being a role and 1 being a member. Returns: The data received from the API after making the call. \"\"\" payload : dict = {} update_payload ( payload , allow = allow , deny = deny , type = type ) return await self . request ( method = \"PUT\" , path = f \"/channels/ { channel_id } /permissions/ { overwrite_id } \" , json = payload , )","title":"edit_channel_permissions()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.delete_channel_permissions","text":"Makes an API call to delete an overwrite from a channel. Parameters: Name Type Description Default channel_id int The ID of the channel. required overwrite_id int The ID of the overwrite. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_channel_permissions ( self , channel_id : int , overwrite_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to delete an overwrite from a channel. Parameters: channel_id (int): The ID of the channel. overwrite_id (int): The ID of the overwrite. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /permissions/ { overwrite_id } \" )","title":"delete_channel_permissions()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_channel_invites","text":"Makes an API call to get a channels invites. Parameters: Name Type Description Default channel_id int The ID of the channel. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_channel_invites ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a channels invites. Parameters: channel_id (int): The ID of the channel. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /invites\" )","title":"get_channel_invites()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.create_channel_invite","text":"Makes an API call to create an invite. Parameters: Name Type Description Default channel_id int The ID of the channel. required max_age int The max age of the invite. 86400 max_uses int The max uses of the invite. 0 if unlimited. 0 temporary bool Whether or not the invite is temporary. False unique bool Whether or not the invite is unique. False target_type Optional[int] The type of the invite. For voice channels. None target_user_id Optional[int] The ID of the user whose stream to invite to. For voice channels. None target_application_id Optional[int] The ID of embedded application to invite from. For target type 2. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def create_channel_invite ( self , channel_id : int , * , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ int ] = None , target_user_id : Optional [ int ] = None , target_application_id : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to create an invite. Parameters: channel_id (int): The ID of the channel. max_age (int): The max age of the invite. max_uses (int): The max uses of the invite. 0 if unlimited. temporary (bool): Whether or not the invite is temporary. unique (bool): Whether or not the invite is unique. target_type (Optional[int]): The type of the invite. For voice channels. target_user_id (Optional[int]): The ID of the user whose stream to invite to. For voice channels. target_application_id (Optional[int]): The ID of embedded application to invite from. For target type 2. Returns: The data received from the API after making the call. \"\"\" payload = { \"max_age\" : max_age , \"max_uses\" : max_uses , \"temporary\" : temporary , \"unique\" : unique , } update_payload ( payload , target_type = target_type , target_user_id = target_user_id , target_application_id = target_application_id , ) return await self . request ( \"POST\" , f \"/channels/ { channel_id } /invites\" , json = payload )","title":"create_channel_invite()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.follow_news_channel","text":"Makes an API call to follow a news channel to send messages to a target channel. Parameters: Name Type Description Default channel_id int The ID Of the channel. required webhook_channel_id int The target channel. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def follow_news_channel ( self , channel_id : int , webhook_channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to follow a news channel to send messages to a target channel. Parameters: channel_id (int): The ID Of the channel. webhook_channel_id (int): The target channel. Returns: The data received from the API after making the call. \"\"\" payload = { \"webhook_channel_id\" : webhook_channel_id } return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /followers/@me\" , json = payload )","title":"follow_news_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.trigger_typing","text":"Makes an API call to trigger typing. Parameters: Name Type Description Default channel_id int The ID of the channel which to trigger typing in. required Returns: Type Description Dict[str, Any] The data received from the API After making the call. Source code in lefi/http.py async def trigger_typing ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to trigger typing. Parameters: channel_id (int): The ID of the channel which to trigger typing in. Returns: The data received from the API After making the call. \"\"\" return await self . request ( \"POST\" , f \"/channels/ { channel_id } /typing\" )","title":"trigger_typing()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_pinned_messages","text":"Makes an API call to get the pinned messages of a channel. Parameters: Name Type Description Default channel_id int The ID of the channel which to grab pinned messages from. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_pinned_messages ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get the pinned messages of a channel. Parameters: channel_id (int): The ID of the channel which to grab pinned messages from. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /pins\" )","title":"get_pinned_messages()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.pin_message","text":"Makes an API call to pin a message. Parameters: Name Type Description Default channel_id int The ID of the channel where the message is. required message_id int The ID of the message. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def pin_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to pin a message. Parameters: channel_id (int): The ID of the channel where the message is. message_id (int): The ID of the message. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /pins/ { message_id } \" )","title":"pin_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.unpin_message","text":"Makes an API call to unpin a message. Parameters: Name Type Description Default channel_id int The ID Of the channel where the message is. required message_id int The ID of the message. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def unpin_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to unpin a message. Parameters: channel_id (int): The ID Of the channel where the message is. message_id (int): The ID of the message. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /pins/ { message_id } \" )","title":"unpin_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.start_thread_with_message","text":"Makes an API call to start a thread with a message. Parameters: Name Type Description Default channel_id int The ID of the channel which the message is in. required message_id int The ID Of the message. required name str The name of the thread. required auto_archive_duration int The time it takes to auto archive the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def start_thread_with_message ( self , channel_id : int , message_id : int , * , name : str , auto_archive_duration : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to start a thread with a message. Parameters: channel_id (int): The ID of the channel which the message is in. message_id (int): The ID Of the message. name (str): The name of the thread. auto_archive_duration (int): The time it takes to auto archive the thread. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , \"auto_archive_duration\" : auto_archive_duration } return await self . request ( method = \"POST\" , path = f \"/channels/ { channel_id } /messages/ { message_id } /threads\" , json = payload , )","title":"start_thread_with_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.start_thread_without_message","text":"Makes an API call to start a thread without a message. Parameters: Name Type Description Default channel_id int The ID of the channel where the thread will be created. required name str The name of the thread. required auto_archive_duration int The time it takes to auto archive the thread. required type int The type of the thread to create. None invitable bool Whether or not members can invite other members to the thread. Only in private threads. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def start_thread_without_message ( self , channel_id : int , * , name : str , auto_archive_duration : int , type : Optional [ int ] = None , invitable : Optional [ bool ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to start a thread without a message. Parameters: channel_id (int): The ID of the channel where the thread will be created. name (str): The name of the thread. auto_archive_duration (int): The time it takes to auto archive the thread. type (int): The type of the thread to create. invitable (bool): Whether or not members can invite other members to the thread. Only in private threads. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , \"auto_archive_duration\" : auto_archive_duration } update_payload ( payload , type = type , invitable = invitable ) return await self . request ( method = \"POST\" , path = f \"/channels/ { channel_id } /threads\" , json = payload )","title":"start_thread_without_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.join_thread","text":"Makes an API call which makes the client join the given thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def join_thread ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which makes the client join the given thread. Parameters: channel_id (int): The ID of the thread. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /thread-members/@me\" )","title":"join_thread()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.add_thread_member","text":"Makes an API call which adds another member to the thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required user_id int The ID of the user to add. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def add_thread_member ( self , channel_id : int , user_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which adds another member to the thread. Parameters: channel_id (int): The ID of the thread. user_id (int): The ID of the user to add. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"PUT\" , f \"/channels/ { channel_id } /thread-members/ { user_id } \" )","title":"add_thread_member()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.leave_thread","text":"Makes an API call which makes the client leave the thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def leave_thread ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which makes the client leave the thread. Parameters: channel_id (int): The ID of the thread. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /thread-members/@me\" )","title":"leave_thread()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.remove_thread_member","text":"Makes an API call which removes a member from the thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required user_id int The ID of the user to remove. required Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def remove_thread_member ( self , channel_id : int , user_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which removes a member from the thread. Parameters: channel_id (int): The ID of the thread. user_id (int): The ID of the user to remove. Returns: The data received from the API after making the call \"\"\" return await self . request ( \"DELETE\" , f \"/channels/ { channel_id } /thread-members/ { user_id } \" )","title":"remove_thread_member()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.list_thread_members","text":"Makes an API call to get all of the members of a thread. Parameters: Name Type Description Default channel_id int The ID of the thread. required Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def list_thread_members ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get all of the members of a thread. Parameters: channel_id (int): The ID of the thread. Returns: The data received from the API after making the call \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /thread-members\" )","title":"list_thread_members()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.list_public_archived_threads","text":"Makes an API call which list all the public archived threads in the channel. Parameters: Name Type Description Default channel_id int The ID of the channel which the threads are inside of. required before Optional[int] Grab threads before this time. None limit Optional[int] The amount of threads to grab. None Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def list_public_archived_threads ( self , channel_id : int , * , before : Optional [ int ] = None , limit : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call which list all the public archived threads in the channel. Parameters: channel_id (int): The ID of the channel which the threads are inside of. before (Optional[int]): Grab threads before this time. limit (Optional[int]): The amount of threads to grab. Returns: The data received from the API after making the call \"\"\" params = update_payload ({}, before = before , limit = limit ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/public\" , params = params )","title":"list_public_archived_threads()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.list_private_archived_threads","text":"Makes an API call which list all the private archived threads in the channel. Parameters: Name Type Description Default channel_id int The ID of the channel which the threads are inside of. required before Optional[int] Grab threads before this time. None limit Optional[int] The amount of threads to grab. None Returns: Type Description The data received from the API after making the call Source code in lefi/http.py async def list_private_archived_threads ( self , channel_id : int , * , before : Optional [ int ] = None , limit : Optional [ int ] = None , ): \"\"\" Makes an API call which list all the private archived threads in the channel. Parameters: channel_id (int): The ID of the channel which the threads are inside of. before (Optional[int]): Grab threads before this time. limit (Optional[int]): The amount of threads to grab. Returns: The data received from the API after making the call \"\"\" params = update_payload ({}, before = before , limit = limit ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/private\" , params = params )","title":"list_private_archived_threads()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.list_joined_private_archived_threads","text":"Makes an API call which list all the private archived threads in the channel which the client has joined. Parameters: Name Type Description Default channel_id int The ID of the channel which the threads are inside of. required before Optional[int] Grab threads before this time. None limit Optional[int] The amount of threads to grab. None Returns: Type Description Dict[str, Any] The data received from the API after making the call Source code in lefi/http.py async def list_joined_private_archived_threads ( self , channel_id : int , * , before : Optional [ int ] = None , limit : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call which list all the private archived threads in the channel which the client has joined. Parameters: channel_id (int): The ID of the channel which the threads are inside of. before (Optional[int]): Grab threads before this time. limit (Optional[int]): The amount of threads to grab. Returns: The data received from the API after making the call \"\"\" params = update_payload ({}, before = before , limit = limit ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /users/@me/threads/archived/private\" , params = params , )","title":"list_joined_private_archived_threads()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.list_guild_emojis","text":"Makes an API call to get a list of the guilds emojis. Parameters: Name Type Description Default guild_id int The ID of the guild to grab from. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def list_guild_emojis ( self , guild_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of the guilds emojis. Parameters: guild_id (int): The ID of the guild to grab from. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/guilds/ { guild_id } /emojis\" )","title":"list_guild_emojis()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_guild_emoji","text":"Makes an API call to get an emoji from the guild. Parameters: Name Type Description Default guild_id int The ID of the guild to grab from. required emoji_id int The ID of the emoji to get. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_guild_emoji ( self , guild_id : int , emoji_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get an emoji from the guild. Parameters: guild_id (int): The ID of the guild to grab from. emoji_id (int): The ID of the emoji to get. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" )","title":"get_guild_emoji()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.create_guild_emoji","text":"Makes an API call to create an emoji. Parameters: Name Type Description Default guild_id int The ID of the guild to create the emoji in. required name str The name of the emoji. required image str The image of the emoji. required roles Optional[List[int]] The list of roles that can use this emoji. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def create_guild_emoji ( self , guild_id : int , * , name : str , image : str , roles : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to create an emoji. Parameters: guild_id (int): The ID of the guild to create the emoji in. name (str): The name of the emoji. image (str): The image of the emoji. roles (Optional[List[int]]): The list of roles that can use this emoji. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , \"image\" : image , \"roles\" : [] if roles is None else roles , } return await self . request ( method = \"POST\" , path = f \"/guilds/ { guild_id } /emojis\" , json = payload )","title":"create_guild_emoji()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.modify_guild_emoji","text":"Makes an API call to edit an emoji. Parameters: Name Type Description Default guild_id int The ID of the guild where the emoji is. required emoji_id int The ID of the emoji. required name str The new name of the emoji. required roles Optional[List[int]] The new list of roles that can use this emoji. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def modify_guild_emoji ( self , guild_id : int , emoji_id : int , * , name : str , roles : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit an emoji. Parameters: guild_id (int): The ID of the guild where the emoji is. emoji_id (int): The ID of the emoji. name (str): The new name of the emoji. roles (Optional[List[int]]): The new list of roles that can use this emoji. Returns: The data received from the API after making the call. \"\"\" payload = { \"name\" : name , } update_payload ( payload , roles = roles ) return await self . request ( method = \"PATCH\" , path = f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" , json = payload )","title":"modify_guild_emoji()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.delete_guild_emoji","text":"Makes an API call which deletes an emoji. Parameters: Name Type Description Default guild_id int The ID of the guild where the emoji is in. required emoji_id int The ID of the emoji to delete. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_guild_emoji ( self , guild_id : int , emoji_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which deletes an emoji. Parameters: guild_id (int): The ID of the guild where the emoji is in. emoji_id (int): The ID of the emoji to delete. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" )","title":"delete_guild_emoji()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.create_dm_channel","text":"Makes an API call which creates a DM channel to a user. Parameters: Name Type Description Default recipient_id int The ID of the user which to open the DM channel to. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def create_dm_channel ( self , recipient_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which creates a DM channel to a user. Parameters: recipient_id (int): The ID of the user which to open the DM channel to. Returns: The data received from the API after making the call. \"\"\" payload = { \"recipient_id\" : recipient_id } return await self . request ( \"POST\" , \"/users/@me/channels\" , json = payload )","title":"create_dm_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.modifiy_guild_role","text":"Makes an API call which edits a role. Parameters: Name Type Description Default guild_id int The ID of the guild where the role is. required role_id int The ID of the role. required name Optional[str] The new name of the role. None permissions Optional[int] The new permissions of the role. None color Optional[int] The new color of the role. None hoist Optional[bool] Whether or not to hoist the role. None mentionable Optional[bool] Whether or not the role should be mentionable. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def modifiy_guild_role ( self , guild_id : int , role_id : int , * , name : Optional [ str ] = None , permissions : Optional [ int ] = None , color : Optional [ int ] = None , hoist : Optional [ bool ] = None , mentionable : Optional [ bool ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call which edits a role. Parameters: guild_id (int): The ID of the guild where the role is. role_id (int): The ID of the role. name (Optional[str]): The new name of the role. permissions (Optional[int]): The new permissions of the role. color (Optional[int]): The new color of the role. hoist (Optional[bool]): Whether or not to hoist the role. mentionable (Optional[bool]): Whether or not the role should be mentionable. Returns: The data received from the API after making the call. \"\"\" payload = update_payload ( {}, name = name , permissions = permissions , color = color , hoist = hoist , mentionable = mentionable , ) return await self . request ( method = \"PATCH\" , path = f \"/guilds/ { guild_id } /roles/ { role_id } \" , json = payload )","title":"modifiy_guild_role()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.delete_guild_role","text":"Makes an API call which deletes a role. Parameters: Name Type Description Default guild_id int The ID of the guild where the role is. required role_id int The ID of the role. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def delete_guild_role ( self , guild_id : int , role_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call which deletes a role. Parameters: guild_id (int): The ID of the guild where the role is. role_id (int): The ID of the role. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"DELETE\" , f \"/guilds/ { guild_id } /roles/ { role_id } \" )","title":"delete_guild_role()"},{"location":"API-Reference/state/","text":"A class which represents the connection state between the client and discord. Attributes: Name Type Description client lefi.Client The lefi.Client instance being used. loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop being used. http lefi.HTTPClient The lefi.HTTPClient handling requests Danger This class is used internally. It is not meant to called directly __init__ ( self , client , loop ) special Parameters: Name Type Description Default client lefi.Client The client being used. required loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop being used. required Source code in lefi/state.py def __init__ ( self , client : Client , loop : asyncio . AbstractEventLoop ): \"\"\" Parameters: client (lefi.Client): The client being used. loop (asyncio.AbstractEventLoop): The [asyncio.AbstractEventLoop][] being used. \"\"\" self . client = client self . loop = loop self . http = client . http self . _messages = Cache [ Message ]( 1000 ) self . _users = Cache [ User ]() self . _guilds = Cache [ Guild ]() self . _channels = Cache [ Union [ TextChannel , DMChannel , VoiceChannel , CategoryChannel , Channel ] ]() dispatch ( self , event , * payload ) Dispatches data to callbacks registered to events after parsing is finished. Parameters: Name Type Description Default event str The name of the event to dispatch to. required *payload Any The data after parsing is finished. () Source code in lefi/state.py def dispatch ( self , event : str , * payload : Any ) -> None : \"\"\" Dispatches data to callbacks registered to events after parsing is finished. Parameters: event (str): The name of the event to dispatch to. *payload (Any): The data after parsing is finished. \"\"\" events = self . client . events . get ( event , []) futures = self . client . futures . get ( event , []) if callbacks := self . client . once_events . get ( event ): for index , callback in enumerate ( callbacks ): self . loop . create_task ( callback ( * payload )) callbacks . pop ( index ) return for future , check in futures : if check ( * payload ): future . set_result ( * payload ) futures . remove (( future , check )) break for callback in events : self . loop . create_task ( callback ( * payload )) parse_ready ( self , data ) async Parses the READY event. Creates a User then dispatches it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_ready ( self , data : Dict ) -> None : \"\"\" Parses the `READY` event. Creates a User then dispatches it afterwards. Parameters: data (Dict): The raw data. \"\"\" user = User ( self , data [ \"user\" ]) self . dispatch ( \"ready\" , user ) parse_guild_create ( self , data ) async Parses GUILD_CREATE event. Creates a Guild then caches it, as well as dispatching it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_guild_create ( self , data : Dict ) -> None : \"\"\" Parses `GUILD_CREATE` event. Creates a Guild then caches it, as well as dispatching it afterwards. Parameters: data (Dict): The raw data. \"\"\" guild = Guild ( self , data ) self . create_guild_channels ( guild , data ) self . create_guild_members ( guild , data ) self . create_guild_roles ( guild , data ) self . _guilds [ guild . id ] = guild self . dispatch ( \"guild_create\" , guild ) parse_message_create ( self , data ) async Parses MESSAGE_CREATE event. Creates a Message then caches it, as well as dispatching it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_message_create ( self , data : Dict ) -> None : \"\"\" Parses `MESSAGE_CREATE` event. Creates a Message then caches it, as well as dispatching it afterwards. Parameters: data (Dict): The raw data. \"\"\" self . add_user ( data [ \"author\" ]) channel = self . _channels . get ( int ( data [ \"channel_id\" ])) message = Message ( self , data , channel ) # type: ignore self . _messages [ message . id ] = message self . dispatch ( \"message_create\" , message ) parse_message_delete ( self , data ) async Parses MESSAGE_DELETE event. Retrieves the message from cache if possible. Else it dispatches a DeletedMessage . Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_message_delete ( self , data : Dict ) -> None : \"\"\" Parses `MESSAGE_DELETE` event. Retrieves the message from cache if possible. Else it dispatches a `DeletedMessage`. Parameters: data (Dict): The raw data. \"\"\" deleted = DeletedMessage ( data ) message = self . _messages . get ( deleted . id ) if message : self . _messages . pop ( message . id ) else : message = deleted # type: ignore self . dispatch ( \"message_delete\" , message ) parse_message_update ( self , data ) async Parses MESSAGE_UPDATE event. Dispatches before and after . Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_message_update ( self , data : Dict ) -> None : \"\"\" Parses `MESSAGE_UPDATE` event. Dispatches `before` and `after`. Parameters: data (Dict): The raw data. \"\"\" channel = self . get_channel ( int ( data [ \"channel_id\" ])) if not channel : return after = self . create_message ( data , channel ) if not ( before := self . get_message ( after . id )): msg = await self . http . get_channel_message ( channel . id , after . id ) before = self . create_message ( msg , channel ) else : self . _messages . pop ( before . id ) self . _messages [ after . id ] = after self . dispatch ( \"message_update\" , before , after ) parse_channel_create ( self , data ) async Parses CHANNEL_CREATE event. Creates a Channel then caches it, as well as dispatching it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_channel_create ( self , data : Dict ) -> None : \"\"\" Parses `CHANNEL_CREATE` event. Creates a Channel then caches it, as well as dispatching it afterwards. Parameters: data (Dict): The raw data. \"\"\" if guild_id := data . get ( \"guild_id\" ): guild = self . get_guild ( int ( guild_id )) channel = self . create_channel ( data , guild ) else : channel = self . create_channel ( data ) self . _channels [ channel . id ] = channel self . dispatch ( \"channel_create\" , channel ) parse_channel_update ( self , data ) async Parses CHANNEL_UPDATE event. Dispatches before and after . Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_channel_update ( self , data : Dict ) -> None : \"\"\" Parses `CHANNEL_UPDATE` event. Dispatches `before` and `after`. Parameters: data (Dict): The raw data. \"\"\" guild = self . get_guild ( int ( data [ \"guild_id\" ])) before = self . get_channel ( int ( data [ \"id\" ])) after = self . create_channel ( data , guild ) self . _channels [ after . id ] = after self . dispatch ( \"channel_update\" , before , after ) parse_channel_delete ( self , data ) async Parses CHANNEL_DELETE event. Dispatches the deleted channel. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_channel_delete ( self , data : Dict ) -> None : \"\"\" Parses `CHANNEL_DELETE` event. Dispatches the deleted channel. Parameters: data (Dict): The raw data. \"\"\" channel = self . get_channel ( int ( data [ \"id\" ])) self . _channels . pop ( channel . id ) # type: ignore self . dispatch ( \"channel_delete\" , channel ) get_message ( self , message_id ) Grabs a message from the cache. Parameters: Name Type Description Default message_id int The ID of the message. required Returns: Type Description Optional[Message] The lefi.Message insance corresponding to the ID if found. Source code in lefi/state.py def get_message ( self , message_id : int ) -> Optional [ Message ]: \"\"\" Grabs a message from the cache. Parameters: message_id (int): The ID of the message. Returns: The [lefi.Message][] insance corresponding to the ID if found. \"\"\" return self . _messages . get ( message_id ) get_user ( self , user_id ) Grabs a user from the cache. Parameters: Name Type Description Default user_id int The ID of the user. required Returns: Type Description Optional[User] The lefi.User instance corresponding to the ID if found. Source code in lefi/state.py def get_user ( self , user_id : int ) -> Optional [ User ]: \"\"\" Grabs a user from the cache. Parameters: user_id (int): The ID of the user. Returns: The [lefi.User][] instance corresponding to the ID if found. \"\"\" return self . _users . get ( user_id ) add_user ( self , data ) Creates a user then caches it. Parameters: Name Type Description Default data Dict The data of the user. required Returns: Type Description User The created lefi.User instance. Source code in lefi/state.py def add_user ( self , data : Dict ) -> User : \"\"\" Creates a user then caches it. Parameters: data (Dict): The data of the user. Returns: The created [lefi.User][] instance. \"\"\" user = User ( self , data ) self . _users [ user . id ] = user return user get_guild ( self , guild_id ) Grabs a guild from the cache. Parameters: Name Type Description Default guild_id int The ID of the guild. required Returns: Type Description Optional[Guild] The lefi.Guild instance corresponding to the ID if found. Source code in lefi/state.py def get_guild ( self , guild_id : int ) -> Optional [ Guild ]: \"\"\" Grabs a guild from the cache. Parameters: guild_id (int): The ID of the guild. Returns: The [lefi.Guild][] instance corresponding to the ID if found. \"\"\" return self . _guilds . get ( guild_id ) get_channel ( self , channel_id ) Grabs a channel from the cache. Parameters: Name Type Description Default channel_id int The ID of the channel. required Returns: Type Description Optional[Union[TextChannel, DMChannel, VoiceChannel, CategoryChannel, Channel]] The lefi.Channel instance corresponding to the ID if found. Source code in lefi/state.py def get_channel ( self , channel_id : int ) -> Optional [ Union [ TextChannel , DMChannel , VoiceChannel , CategoryChannel , Channel ] ]: \"\"\" Grabs a channel from the cache. Parameters: channel_id (int): The ID of the channel. Returns: The [lefi.Channel][] instance corresponding to the ID if found. \"\"\" return self . _channels . get ( channel_id ) create_message ( self , data , channel ) Creates a Message instance. Parameters: Name Type Description Default data Dict The data of the message. required channel Any The channel of the message. required Returns: Type Description Message The created lefi.Message instance. Source code in lefi/state.py def create_message ( self , data : Dict , channel : Any ) -> Message : \"\"\" Creates a Message instance. Parameters: data (Dict): The data of the message. channel (Any): The channel of the message. Returns: The created [lefi.Message][] instance. \"\"\" return Message ( self , data , channel ) create_channel ( self , data , * args ) Creates a Channel instance. Parameters: Name Type Description Default data Dict The data of the channel. required *args Any Extra arguments to pass to the channels constructor. () Returns: Type Description Union[TextChannel, VoiceChannel, CategoryChannel, Channel] The created lefi.Channel instance. Source code in lefi/state.py def create_channel ( self , data : Dict , * args ) -> Union [ TextChannel , VoiceChannel , CategoryChannel , Channel ]: \"\"\" Creates a Channel instance. Parameters: data (Dict): The data of the channel. *args (Any): Extra arguments to pass to the channels constructor. Returns: The created [lefi.Channel][] instance. \"\"\" cls = self . CHANNEL_MAPPING . get ( int ( data [ \"type\" ]), Channel ) return cls ( self , data , * args ) # type: ignore create_guild_channels ( self , guild , data ) Creates the channels of a guild. Parameters: Name Type Description Default guild lefi.Guild The guild which to create the channels for. required data Dict The data of the channels. required Returns: Type Description Guild The lefi.Guild instance passed in. Source code in lefi/state.py def create_guild_channels ( self , guild : Guild , data : Dict ) -> Guild : \"\"\" Creates the channels of a guild. Parameters: guild (lefi.Guild): The guild which to create the channels for. data (Dict): The data of the channels. Returns: The [lefi.Guild][] instance passed in. \"\"\" channels = { int ( payload [ \"id\" ]): self . create_channel ( payload , guild ) for payload in data [ \"channels\" ] } for channel in channels . values (): self . _channels [ channel . id ] = channel guild . _channels = channels return guild create_guild_members ( self , guild , data ) Creates the members of a guild. Parameters: Name Type Description Default guild lefi.Guild The guild which to create the channels for. required data Dict The data of the members. required Returns: Type Description Guild The lefi.Guild instance passed in. Source code in lefi/state.py def create_guild_members ( self , guild : Guild , data : Dict ) -> Guild : \"\"\" Creates the members of a guild. Parameters: guild (lefi.Guild): The guild which to create the channels for. data (Dict): The data of the members. Returns: The [lefi.Guild][] instance passed in. \"\"\" members = { int ( payload [ \"user\" ][ \"id\" ]): Member ( self , payload , guild ) for payload in data [ \"members\" ] } guild . _members = members return guild create_guild_roles ( self , guild , data ) Creates the roles of a guild. Parameters: Name Type Description Default guild lefi.Guild The guild which to create the channels for. required data Dict The data of the roles. required Returns: Type Description Guild The lefi.Guild instance passed in. Source code in lefi/state.py def create_guild_roles ( self , guild : Guild , data : Dict ) -> Guild : \"\"\" Creates the roles of a guild. Parameters: guild (lefi.Guild): The guild which to create the channels for. data (Dict): The data of the roles. Returns: The [lefi.Guild][] instance passed in. \"\"\" roles = { int ( payload [ \"id\" ]): Role ( self , payload , guild ) for payload in data [ \"roles\" ] } guild . _roles = roles return guild","title":"State"},{"location":"API-Reference/state/#lefi.state.State.__init__","text":"Parameters: Name Type Description Default client lefi.Client The client being used. required loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop being used. required Source code in lefi/state.py def __init__ ( self , client : Client , loop : asyncio . AbstractEventLoop ): \"\"\" Parameters: client (lefi.Client): The client being used. loop (asyncio.AbstractEventLoop): The [asyncio.AbstractEventLoop][] being used. \"\"\" self . client = client self . loop = loop self . http = client . http self . _messages = Cache [ Message ]( 1000 ) self . _users = Cache [ User ]() self . _guilds = Cache [ Guild ]() self . _channels = Cache [ Union [ TextChannel , DMChannel , VoiceChannel , CategoryChannel , Channel ] ]()","title":"__init__()"},{"location":"API-Reference/state/#lefi.state.State.dispatch","text":"Dispatches data to callbacks registered to events after parsing is finished. Parameters: Name Type Description Default event str The name of the event to dispatch to. required *payload Any The data after parsing is finished. () Source code in lefi/state.py def dispatch ( self , event : str , * payload : Any ) -> None : \"\"\" Dispatches data to callbacks registered to events after parsing is finished. Parameters: event (str): The name of the event to dispatch to. *payload (Any): The data after parsing is finished. \"\"\" events = self . client . events . get ( event , []) futures = self . client . futures . get ( event , []) if callbacks := self . client . once_events . get ( event ): for index , callback in enumerate ( callbacks ): self . loop . create_task ( callback ( * payload )) callbacks . pop ( index ) return for future , check in futures : if check ( * payload ): future . set_result ( * payload ) futures . remove (( future , check )) break for callback in events : self . loop . create_task ( callback ( * payload ))","title":"dispatch()"},{"location":"API-Reference/state/#lefi.state.State.parse_ready","text":"Parses the READY event. Creates a User then dispatches it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_ready ( self , data : Dict ) -> None : \"\"\" Parses the `READY` event. Creates a User then dispatches it afterwards. Parameters: data (Dict): The raw data. \"\"\" user = User ( self , data [ \"user\" ]) self . dispatch ( \"ready\" , user )","title":"parse_ready()"},{"location":"API-Reference/state/#lefi.state.State.parse_guild_create","text":"Parses GUILD_CREATE event. Creates a Guild then caches it, as well as dispatching it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_guild_create ( self , data : Dict ) -> None : \"\"\" Parses `GUILD_CREATE` event. Creates a Guild then caches it, as well as dispatching it afterwards. Parameters: data (Dict): The raw data. \"\"\" guild = Guild ( self , data ) self . create_guild_channels ( guild , data ) self . create_guild_members ( guild , data ) self . create_guild_roles ( guild , data ) self . _guilds [ guild . id ] = guild self . dispatch ( \"guild_create\" , guild )","title":"parse_guild_create()"},{"location":"API-Reference/state/#lefi.state.State.parse_message_create","text":"Parses MESSAGE_CREATE event. Creates a Message then caches it, as well as dispatching it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_message_create ( self , data : Dict ) -> None : \"\"\" Parses `MESSAGE_CREATE` event. Creates a Message then caches it, as well as dispatching it afterwards. Parameters: data (Dict): The raw data. \"\"\" self . add_user ( data [ \"author\" ]) channel = self . _channels . get ( int ( data [ \"channel_id\" ])) message = Message ( self , data , channel ) # type: ignore self . _messages [ message . id ] = message self . dispatch ( \"message_create\" , message )","title":"parse_message_create()"},{"location":"API-Reference/state/#lefi.state.State.parse_message_delete","text":"Parses MESSAGE_DELETE event. Retrieves the message from cache if possible. Else it dispatches a DeletedMessage . Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_message_delete ( self , data : Dict ) -> None : \"\"\" Parses `MESSAGE_DELETE` event. Retrieves the message from cache if possible. Else it dispatches a `DeletedMessage`. Parameters: data (Dict): The raw data. \"\"\" deleted = DeletedMessage ( data ) message = self . _messages . get ( deleted . id ) if message : self . _messages . pop ( message . id ) else : message = deleted # type: ignore self . dispatch ( \"message_delete\" , message )","title":"parse_message_delete()"},{"location":"API-Reference/state/#lefi.state.State.parse_message_update","text":"Parses MESSAGE_UPDATE event. Dispatches before and after . Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_message_update ( self , data : Dict ) -> None : \"\"\" Parses `MESSAGE_UPDATE` event. Dispatches `before` and `after`. Parameters: data (Dict): The raw data. \"\"\" channel = self . get_channel ( int ( data [ \"channel_id\" ])) if not channel : return after = self . create_message ( data , channel ) if not ( before := self . get_message ( after . id )): msg = await self . http . get_channel_message ( channel . id , after . id ) before = self . create_message ( msg , channel ) else : self . _messages . pop ( before . id ) self . _messages [ after . id ] = after self . dispatch ( \"message_update\" , before , after )","title":"parse_message_update()"},{"location":"API-Reference/state/#lefi.state.State.parse_channel_create","text":"Parses CHANNEL_CREATE event. Creates a Channel then caches it, as well as dispatching it afterwards. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_channel_create ( self , data : Dict ) -> None : \"\"\" Parses `CHANNEL_CREATE` event. Creates a Channel then caches it, as well as dispatching it afterwards. Parameters: data (Dict): The raw data. \"\"\" if guild_id := data . get ( \"guild_id\" ): guild = self . get_guild ( int ( guild_id )) channel = self . create_channel ( data , guild ) else : channel = self . create_channel ( data ) self . _channels [ channel . id ] = channel self . dispatch ( \"channel_create\" , channel )","title":"parse_channel_create()"},{"location":"API-Reference/state/#lefi.state.State.parse_channel_update","text":"Parses CHANNEL_UPDATE event. Dispatches before and after . Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_channel_update ( self , data : Dict ) -> None : \"\"\" Parses `CHANNEL_UPDATE` event. Dispatches `before` and `after`. Parameters: data (Dict): The raw data. \"\"\" guild = self . get_guild ( int ( data [ \"guild_id\" ])) before = self . get_channel ( int ( data [ \"id\" ])) after = self . create_channel ( data , guild ) self . _channels [ after . id ] = after self . dispatch ( \"channel_update\" , before , after )","title":"parse_channel_update()"},{"location":"API-Reference/state/#lefi.state.State.parse_channel_delete","text":"Parses CHANNEL_DELETE event. Dispatches the deleted channel. Parameters: Name Type Description Default data Dict The raw data. required Source code in lefi/state.py async def parse_channel_delete ( self , data : Dict ) -> None : \"\"\" Parses `CHANNEL_DELETE` event. Dispatches the deleted channel. Parameters: data (Dict): The raw data. \"\"\" channel = self . get_channel ( int ( data [ \"id\" ])) self . _channels . pop ( channel . id ) # type: ignore self . dispatch ( \"channel_delete\" , channel )","title":"parse_channel_delete()"},{"location":"API-Reference/state/#lefi.state.State.get_message","text":"Grabs a message from the cache. Parameters: Name Type Description Default message_id int The ID of the message. required Returns: Type Description Optional[Message] The lefi.Message insance corresponding to the ID if found. Source code in lefi/state.py def get_message ( self , message_id : int ) -> Optional [ Message ]: \"\"\" Grabs a message from the cache. Parameters: message_id (int): The ID of the message. Returns: The [lefi.Message][] insance corresponding to the ID if found. \"\"\" return self . _messages . get ( message_id )","title":"get_message()"},{"location":"API-Reference/state/#lefi.state.State.get_user","text":"Grabs a user from the cache. Parameters: Name Type Description Default user_id int The ID of the user. required Returns: Type Description Optional[User] The lefi.User instance corresponding to the ID if found. Source code in lefi/state.py def get_user ( self , user_id : int ) -> Optional [ User ]: \"\"\" Grabs a user from the cache. Parameters: user_id (int): The ID of the user. Returns: The [lefi.User][] instance corresponding to the ID if found. \"\"\" return self . _users . get ( user_id )","title":"get_user()"},{"location":"API-Reference/state/#lefi.state.State.add_user","text":"Creates a user then caches it. Parameters: Name Type Description Default data Dict The data of the user. required Returns: Type Description User The created lefi.User instance. Source code in lefi/state.py def add_user ( self , data : Dict ) -> User : \"\"\" Creates a user then caches it. Parameters: data (Dict): The data of the user. Returns: The created [lefi.User][] instance. \"\"\" user = User ( self , data ) self . _users [ user . id ] = user return user","title":"add_user()"},{"location":"API-Reference/state/#lefi.state.State.get_guild","text":"Grabs a guild from the cache. Parameters: Name Type Description Default guild_id int The ID of the guild. required Returns: Type Description Optional[Guild] The lefi.Guild instance corresponding to the ID if found. Source code in lefi/state.py def get_guild ( self , guild_id : int ) -> Optional [ Guild ]: \"\"\" Grabs a guild from the cache. Parameters: guild_id (int): The ID of the guild. Returns: The [lefi.Guild][] instance corresponding to the ID if found. \"\"\" return self . _guilds . get ( guild_id )","title":"get_guild()"},{"location":"API-Reference/state/#lefi.state.State.get_channel","text":"Grabs a channel from the cache. Parameters: Name Type Description Default channel_id int The ID of the channel. required Returns: Type Description Optional[Union[TextChannel, DMChannel, VoiceChannel, CategoryChannel, Channel]] The lefi.Channel instance corresponding to the ID if found. Source code in lefi/state.py def get_channel ( self , channel_id : int ) -> Optional [ Union [ TextChannel , DMChannel , VoiceChannel , CategoryChannel , Channel ] ]: \"\"\" Grabs a channel from the cache. Parameters: channel_id (int): The ID of the channel. Returns: The [lefi.Channel][] instance corresponding to the ID if found. \"\"\" return self . _channels . get ( channel_id )","title":"get_channel()"},{"location":"API-Reference/state/#lefi.state.State.create_message","text":"Creates a Message instance. Parameters: Name Type Description Default data Dict The data of the message. required channel Any The channel of the message. required Returns: Type Description Message The created lefi.Message instance. Source code in lefi/state.py def create_message ( self , data : Dict , channel : Any ) -> Message : \"\"\" Creates a Message instance. Parameters: data (Dict): The data of the message. channel (Any): The channel of the message. Returns: The created [lefi.Message][] instance. \"\"\" return Message ( self , data , channel )","title":"create_message()"},{"location":"API-Reference/state/#lefi.state.State.create_channel","text":"Creates a Channel instance. Parameters: Name Type Description Default data Dict The data of the channel. required *args Any Extra arguments to pass to the channels constructor. () Returns: Type Description Union[TextChannel, VoiceChannel, CategoryChannel, Channel] The created lefi.Channel instance. Source code in lefi/state.py def create_channel ( self , data : Dict , * args ) -> Union [ TextChannel , VoiceChannel , CategoryChannel , Channel ]: \"\"\" Creates a Channel instance. Parameters: data (Dict): The data of the channel. *args (Any): Extra arguments to pass to the channels constructor. Returns: The created [lefi.Channel][] instance. \"\"\" cls = self . CHANNEL_MAPPING . get ( int ( data [ \"type\" ]), Channel ) return cls ( self , data , * args ) # type: ignore","title":"create_channel()"},{"location":"API-Reference/state/#lefi.state.State.create_guild_channels","text":"Creates the channels of a guild. Parameters: Name Type Description Default guild lefi.Guild The guild which to create the channels for. required data Dict The data of the channels. required Returns: Type Description Guild The lefi.Guild instance passed in. Source code in lefi/state.py def create_guild_channels ( self , guild : Guild , data : Dict ) -> Guild : \"\"\" Creates the channels of a guild. Parameters: guild (lefi.Guild): The guild which to create the channels for. data (Dict): The data of the channels. Returns: The [lefi.Guild][] instance passed in. \"\"\" channels = { int ( payload [ \"id\" ]): self . create_channel ( payload , guild ) for payload in data [ \"channels\" ] } for channel in channels . values (): self . _channels [ channel . id ] = channel guild . _channels = channels return guild","title":"create_guild_channels()"},{"location":"API-Reference/state/#lefi.state.State.create_guild_members","text":"Creates the members of a guild. Parameters: Name Type Description Default guild lefi.Guild The guild which to create the channels for. required data Dict The data of the members. required Returns: Type Description Guild The lefi.Guild instance passed in. Source code in lefi/state.py def create_guild_members ( self , guild : Guild , data : Dict ) -> Guild : \"\"\" Creates the members of a guild. Parameters: guild (lefi.Guild): The guild which to create the channels for. data (Dict): The data of the members. Returns: The [lefi.Guild][] instance passed in. \"\"\" members = { int ( payload [ \"user\" ][ \"id\" ]): Member ( self , payload , guild ) for payload in data [ \"members\" ] } guild . _members = members return guild","title":"create_guild_members()"},{"location":"API-Reference/state/#lefi.state.State.create_guild_roles","text":"Creates the roles of a guild. Parameters: Name Type Description Default guild lefi.Guild The guild which to create the channels for. required data Dict The data of the roles. required Returns: Type Description Guild The lefi.Guild instance passed in. Source code in lefi/state.py def create_guild_roles ( self , guild : Guild , data : Dict ) -> Guild : \"\"\" Creates the roles of a guild. Parameters: guild (lefi.Guild): The guild which to create the channels for. data (Dict): The data of the roles. Returns: The [lefi.Guild][] instance passed in. \"\"\" roles = { int ( payload [ \"id\" ]): Role ( self , payload , guild ) for payload in data [ \"roles\" ] } guild . _roles = roles return guild","title":"create_guild_roles()"},{"location":"API-Reference/textchannel/","text":"A class that represents a TextChannel. topic : str property readonly The topic of the channel. last_message : Optional [ Message ] property readonly The last lefi.Message instance sent in the channel. rate_limit_per_user : int property readonly The amount of time needed before another message can be sent in the channel. default_auto_archive_duration : int property readonly The amount of time it takes to archive a thread inside of the channel. parent : Optional [ Channel ] property readonly The channels parent. send ( self , content = None , * , embeds = None ) async Sends a message to the channel. Parameters: Name Type Description Default content Optional[str] The content of the message. None embeds Optional[List[lefi.Embed]] The list of embeds to send with the message. None Returns: Type Description Message The sent lefi.Message instance. Source code in lefi/objects/channel.py async def send ( self , content : Optional [ str ] = None , * , embeds : Optional [ List [ Embed ]] = None ) -> Message : \"\"\" Sends a message to the channel. Parameters: content (Optional[str]): The content of the message. embeds (Optional[List[lefi.Embed]]): The list of embeds to send with the message. Returns: The sent [lefi.Message][] instance. \"\"\" embeds = [] if embeds is None else embeds data = await self . _state . client . http . send_message ( channel_id = self . id , content = content , embeds = [ embed . to_dict () for embed in embeds ], ) return self . _state . create_message ( data , self ) fetch_message ( self , message_id ) async Makes an API call to receive a message. Parameters: Name Type Description Default message_id int The ID of the message. required Returns: Type Description Message The lefi.Message instance corresponding to the ID if found. Source code in lefi/objects/channel.py async def fetch_message ( self , message_id : int ) -> Message : \"\"\" Makes an API call to receive a message. Parameters: message_id (int): The ID of the message. Returns: The [lefi.Message][] instance corresponding to the ID if found. \"\"\" data = await self . _state . http . get_channel_message ( self . id , message_id ) return self . _state . create_message ( data , self )","title":"TextChannel"},{"location":"API-Reference/textchannel/#lefi.objects.channel.TextChannel.topic","text":"The topic of the channel.","title":"topic"},{"location":"API-Reference/textchannel/#lefi.objects.channel.TextChannel.last_message","text":"The last lefi.Message instance sent in the channel.","title":"last_message"},{"location":"API-Reference/textchannel/#lefi.objects.channel.TextChannel.rate_limit_per_user","text":"The amount of time needed before another message can be sent in the channel.","title":"rate_limit_per_user"},{"location":"API-Reference/textchannel/#lefi.objects.channel.TextChannel.default_auto_archive_duration","text":"The amount of time it takes to archive a thread inside of the channel.","title":"default_auto_archive_duration"},{"location":"API-Reference/textchannel/#lefi.objects.channel.TextChannel.parent","text":"The channels parent.","title":"parent"},{"location":"API-Reference/textchannel/#lefi.objects.channel.TextChannel.send","text":"Sends a message to the channel. Parameters: Name Type Description Default content Optional[str] The content of the message. None embeds Optional[List[lefi.Embed]] The list of embeds to send with the message. None Returns: Type Description Message The sent lefi.Message instance. Source code in lefi/objects/channel.py async def send ( self , content : Optional [ str ] = None , * , embeds : Optional [ List [ Embed ]] = None ) -> Message : \"\"\" Sends a message to the channel. Parameters: content (Optional[str]): The content of the message. embeds (Optional[List[lefi.Embed]]): The list of embeds to send with the message. Returns: The sent [lefi.Message][] instance. \"\"\" embeds = [] if embeds is None else embeds data = await self . _state . client . http . send_message ( channel_id = self . id , content = content , embeds = [ embed . to_dict () for embed in embeds ], ) return self . _state . create_message ( data , self )","title":"send()"},{"location":"API-Reference/textchannel/#lefi.objects.channel.TextChannel.fetch_message","text":"Makes an API call to receive a message. Parameters: Name Type Description Default message_id int The ID of the message. required Returns: Type Description Message The lefi.Message instance corresponding to the ID if found. Source code in lefi/objects/channel.py async def fetch_message ( self , message_id : int ) -> Message : \"\"\" Makes an API call to receive a message. Parameters: message_id (int): The ID of the message. Returns: The [lefi.Message][] instance corresponding to the ID if found. \"\"\" data = await self . _state . http . get_channel_message ( self . id , message_id ) return self . _state . create_message ( data , self )","title":"fetch_message()"},{"location":"API-Reference/voicechannel/","text":"Represents a VoiceChannel. user_limit : int property readonly The user limit of the voice channel. bitrate : int property readonly The bitrate of the voice channel. rtc_region : Optional [ str ] property readonly THe rtc region of the voice channel. parent property readonly The parent of the voice channel.","title":"VoiceChannel"},{"location":"API-Reference/voicechannel/#lefi.objects.channel.VoiceChannel.user_limit","text":"The user limit of the voice channel.","title":"user_limit"},{"location":"API-Reference/voicechannel/#lefi.objects.channel.VoiceChannel.bitrate","text":"The bitrate of the voice channel.","title":"bitrate"},{"location":"API-Reference/voicechannel/#lefi.objects.channel.VoiceChannel.rtc_region","text":"THe rtc region of the voice channel.","title":"rtc_region"},{"location":"API-Reference/voicechannel/#lefi.objects.channel.VoiceChannel.parent","text":"The parent of the voice channel.","title":"parent"},{"location":"API-Reference/wsclient/","text":"A class which is used to communicate to the gateway. Attributes: Name Type Description intents lefi.Intents The intents to use when connecting. ws aiohttp.ClientWebSocketResponse The websocket which we are connected to. heartbeat_deylay float The delay inbetween sending each heartbeat. client lefi.Client The lefi.Client currently connected. closed bool Whether or not the websocket is closed. seq int The sequence received from READY . Danger This class is used internally. THIS IS NOT MEANT TO BE TOUCHED. . Doing so can cause bugs. __init__ ( self , client , intents = None ) special Parameters: Name Type Description Default client lefi.Client The lefi.Client instance connected. required intents lefi.Intents The lefi.Intents to pass when connecting. None Source code in lefi/ws/wsclient.py def __init__ ( self , client : Client , intents : Optional [ Intents ] = None ) -> None : \"\"\" Parameters: client (lefi.Client): The [lefi.Client][] instance connected. intents (lefi.Intents): The [lefi.Intents][] to pass when connecting. \"\"\" self . intents = Intents . default () if intents is None else intents self . ws : aiohttp . ClientWebSocketResponse = None # type: ignore self . heartbeat_delay : float = 0 self . client : Client = client self . closed : bool = False self . seq : int = 0 self . EVENT_MAPPING : Dict [ str , Callable ] = { \"ready\" : self . client . _state . parse_ready , \"message_create\" : self . client . _state . parse_message_create , \"message_update\" : self . client . _state . parse_message_update , \"message_delete\" : self . client . _state . parse_message_delete , \"guild_create\" : self . client . _state . parse_guild_create , \"channel_create\" : self . client . _state . parse_channel_create , \"channel_update\" : self . client . _state . parse_channel_update , \"channel_delete\" : self . client . _state . parse_channel_delete , } start ( self ) async Starts the connection to the websocket and begins parsing messages received from the websocket. Source code in lefi/ws/wsclient.py async def start ( self ) -> None : \"\"\" Starts the connection to the websocket and begins parsing messages received from the websocket. \"\"\" data = await self . client . http . get_bot_gateway () self . ws = await self . client . http . ws_connect ( data [ \"url\" ]) await self . identify () await asyncio . gather ( self . start_heartbeat (), self . read_messages ()) parse_event_data ( self , event_name , data ) async Finds the parsers for the passed in event. Parameters: Name Type Description Default event_name str The name of the event. required data Dict The raw data to parse. required Source code in lefi/ws/wsclient.py async def parse_event_data ( self , event_name : str , data : Dict ) -> None : \"\"\" Finds the parsers for the passed in event. Parameters: event_name (str): The name of the event. data (Dict): The raw data to parse. \"\"\" if event_parse := self . EVENT_MAPPING . get ( event_name ): await event_parse ( data ) reconnect ( self ) async Closes the websocket if it isn't then tries to establish a new connection. Source code in lefi/ws/wsclient.py async def reconnect ( self ) -> None : \"\"\" Closes the websocket if it isn't then tries to establish a new connection. \"\"\" if not self . ws . closed and self . ws : await self . ws . close () self . closed = True await self . start () read_messages ( self ) async Reads the messages from received from the websocket and parses them. Source code in lefi/ws/wsclient.py async def read_messages ( self ) -> None : \"\"\" Reads the messages from received from the websocket and parses them. \"\"\" async for message in self . ws : if message . type is aiohttp . WSMsgType . TEXT : recieved_data = message . json () if recieved_data [ \"op\" ] == OpCodes . DISPATCH : await self . dispatch ( recieved_data [ \"t\" ], recieved_data [ \"d\" ]) if recieved_data [ \"op\" ] == OpCodes . HEARTBEAT_ACK : logger . info ( \"HEARTBEAT ACKNOWLEDGED\" ) if recieved_data [ \"op\" ] == OpCodes . RESUME : logger . info ( \"RESUMED\" ) await self . resume () if recieved_data [ \"op\" ] == OpCodes . RECONNECT : logger . info ( \"RECONNECT\" ) await self . reconnect () dispatch ( self , event , data ) async Dispatches an event and its data to the parsers. Parameters: Name Type Description Default event str The event being dispatched. required data Dict The raw data of the event. required Source code in lefi/ws/wsclient.py async def dispatch ( self , event : str , data : Dict ) -> None : \"\"\" Dispatches an event and its data to the parsers. Parameters: event (str): The event being dispatched. data (Dict): The raw data of the event. \"\"\" logger . debug ( f \"DISPATCHED EVENT: { event } \" ) if event == \"READY\" : self . session_id = data [ \"session_id\" ] await self . parse_event_data ( event . lower (), data ) resume ( self ) async Sends a resume payload to the websocket. Source code in lefi/ws/wsclient.py async def resume ( self ) -> None : \"\"\" Sends a resume payload to the websocket. \"\"\" payload = { \"op\" : 6 , \"token\" : self . client . http . token , \"session_id\" : self . session_id , \"seq\" : self . seq , } await self . ws . send_json ( payload ) identify ( self ) async Sends an identify payload to the websocket. Source code in lefi/ws/wsclient.py async def identify ( self ) -> None : \"\"\" Sends an identify payload to the websocket. \"\"\" data = await self . ws . receive () self . heartbeat_delay = data . json ()[ \"d\" ][ \"heartbeat_interval\" ] payload = { \"op\" : 2 , \"d\" : { \"token\" : self . client . http . token , \"intents\" : self . intents . value , \"properties\" : { \"$os\" : sys . platform , \"$browser\" : \"Lefi\" , \"$device\" : \"Lefi\" , }, }, } await self . ws . send_json ( payload ) start_heartbeat ( self ) async Starts the heartbeat loop. Info This can be blocked, which causes the heartbeat to stop. Source code in lefi/ws/wsclient.py async def start_heartbeat ( self ) -> None : \"\"\" Starts the heartbeat loop. Info: This can be blocked, which causes the heartbeat to stop. \"\"\" while not self . closed : self . seq += 1 await self . ws . send_json ({ \"op\" : 1 , \"d\" : self . seq }) logger . info ( \"HEARTBEAT SENT\" ) await asyncio . sleep ( self . heartbeat_delay / 1000 )","title":"WebSocketClient"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.__init__","text":"Parameters: Name Type Description Default client lefi.Client The lefi.Client instance connected. required intents lefi.Intents The lefi.Intents to pass when connecting. None Source code in lefi/ws/wsclient.py def __init__ ( self , client : Client , intents : Optional [ Intents ] = None ) -> None : \"\"\" Parameters: client (lefi.Client): The [lefi.Client][] instance connected. intents (lefi.Intents): The [lefi.Intents][] to pass when connecting. \"\"\" self . intents = Intents . default () if intents is None else intents self . ws : aiohttp . ClientWebSocketResponse = None # type: ignore self . heartbeat_delay : float = 0 self . client : Client = client self . closed : bool = False self . seq : int = 0 self . EVENT_MAPPING : Dict [ str , Callable ] = { \"ready\" : self . client . _state . parse_ready , \"message_create\" : self . client . _state . parse_message_create , \"message_update\" : self . client . _state . parse_message_update , \"message_delete\" : self . client . _state . parse_message_delete , \"guild_create\" : self . client . _state . parse_guild_create , \"channel_create\" : self . client . _state . parse_channel_create , \"channel_update\" : self . client . _state . parse_channel_update , \"channel_delete\" : self . client . _state . parse_channel_delete , }","title":"__init__()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.start","text":"Starts the connection to the websocket and begins parsing messages received from the websocket. Source code in lefi/ws/wsclient.py async def start ( self ) -> None : \"\"\" Starts the connection to the websocket and begins parsing messages received from the websocket. \"\"\" data = await self . client . http . get_bot_gateway () self . ws = await self . client . http . ws_connect ( data [ \"url\" ]) await self . identify () await asyncio . gather ( self . start_heartbeat (), self . read_messages ())","title":"start()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.parse_event_data","text":"Finds the parsers for the passed in event. Parameters: Name Type Description Default event_name str The name of the event. required data Dict The raw data to parse. required Source code in lefi/ws/wsclient.py async def parse_event_data ( self , event_name : str , data : Dict ) -> None : \"\"\" Finds the parsers for the passed in event. Parameters: event_name (str): The name of the event. data (Dict): The raw data to parse. \"\"\" if event_parse := self . EVENT_MAPPING . get ( event_name ): await event_parse ( data )","title":"parse_event_data()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.reconnect","text":"Closes the websocket if it isn't then tries to establish a new connection. Source code in lefi/ws/wsclient.py async def reconnect ( self ) -> None : \"\"\" Closes the websocket if it isn't then tries to establish a new connection. \"\"\" if not self . ws . closed and self . ws : await self . ws . close () self . closed = True await self . start ()","title":"reconnect()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.read_messages","text":"Reads the messages from received from the websocket and parses them. Source code in lefi/ws/wsclient.py async def read_messages ( self ) -> None : \"\"\" Reads the messages from received from the websocket and parses them. \"\"\" async for message in self . ws : if message . type is aiohttp . WSMsgType . TEXT : recieved_data = message . json () if recieved_data [ \"op\" ] == OpCodes . DISPATCH : await self . dispatch ( recieved_data [ \"t\" ], recieved_data [ \"d\" ]) if recieved_data [ \"op\" ] == OpCodes . HEARTBEAT_ACK : logger . info ( \"HEARTBEAT ACKNOWLEDGED\" ) if recieved_data [ \"op\" ] == OpCodes . RESUME : logger . info ( \"RESUMED\" ) await self . resume () if recieved_data [ \"op\" ] == OpCodes . RECONNECT : logger . info ( \"RECONNECT\" ) await self . reconnect ()","title":"read_messages()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.dispatch","text":"Dispatches an event and its data to the parsers. Parameters: Name Type Description Default event str The event being dispatched. required data Dict The raw data of the event. required Source code in lefi/ws/wsclient.py async def dispatch ( self , event : str , data : Dict ) -> None : \"\"\" Dispatches an event and its data to the parsers. Parameters: event (str): The event being dispatched. data (Dict): The raw data of the event. \"\"\" logger . debug ( f \"DISPATCHED EVENT: { event } \" ) if event == \"READY\" : self . session_id = data [ \"session_id\" ] await self . parse_event_data ( event . lower (), data )","title":"dispatch()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.resume","text":"Sends a resume payload to the websocket. Source code in lefi/ws/wsclient.py async def resume ( self ) -> None : \"\"\" Sends a resume payload to the websocket. \"\"\" payload = { \"op\" : 6 , \"token\" : self . client . http . token , \"session_id\" : self . session_id , \"seq\" : self . seq , } await self . ws . send_json ( payload )","title":"resume()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.identify","text":"Sends an identify payload to the websocket. Source code in lefi/ws/wsclient.py async def identify ( self ) -> None : \"\"\" Sends an identify payload to the websocket. \"\"\" data = await self . ws . receive () self . heartbeat_delay = data . json ()[ \"d\" ][ \"heartbeat_interval\" ] payload = { \"op\" : 2 , \"d\" : { \"token\" : self . client . http . token , \"intents\" : self . intents . value , \"properties\" : { \"$os\" : sys . platform , \"$browser\" : \"Lefi\" , \"$device\" : \"Lefi\" , }, }, } await self . ws . send_json ( payload )","title":"identify()"},{"location":"API-Reference/wsclient/#lefi.ws.wsclient.WebSocketClient.start_heartbeat","text":"Starts the heartbeat loop. Info This can be blocked, which causes the heartbeat to stop. Source code in lefi/ws/wsclient.py async def start_heartbeat ( self ) -> None : \"\"\" Starts the heartbeat loop. Info: This can be blocked, which causes the heartbeat to stop. \"\"\" while not self . closed : self . seq += 1 await self . ws . send_json ({ \"op\" : 1 , \"d\" : self . seq }) logger . info ( \"HEARTBEAT SENT\" ) await asyncio . sleep ( self . heartbeat_delay / 1000 )","title":"start_heartbeat()"}]}